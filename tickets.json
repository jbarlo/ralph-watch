{
  "tickets": [
    {
      "id": 1,
      "title": "Init Next.js project with pnpm",
      "description": "Create Next.js 14 app with App Router, TypeScript, pnpm. Use `pnpm create next-app@latest ralph-watch-ui --typescript --tailwind --eslint --app --src-dir --import-alias '@/*'`. Move contents up if nested.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 20,
      "title": "ESLint + Prettier + strict TS + quality check",
      "description": "Install prettier, eslint-config-prettier, eslint-plugin-prettier, lodash, @types/lodash. Create .prettierrc (singleQuote, semi, tabWidth 2). Update .eslintrc to extend prettier. Enable noUncheckedIndexedAccess in tsconfig.json compilerOptions. Add scripts: `format`, `lint`, `typecheck` (tsc --noEmit), `check` (runs all). `pnpm check` must pass after every ticket.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 21,
      "title": "Result type utilities for railway-oriented flow",
      "description": "Create src/lib/result.ts with Result<T, E> type (ok/err discriminated union). Helper functions: ok(value), err(error), isOk(), isErr(), map(), flatMap(), mapErr(). Use for fallible operations instead of throwing.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 22,
      "title": "Test setup with vitest",
      "description": "Install vitest, @testing-library/react, @testing-library/dom. Configure vitest.config.ts. Add `test` script to package.json. Add `test` to the `check` script. Create example integration test for a tRPC endpoint once available.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 2,
      "title": "Add shadcn/ui and configure",
      "description": "Install shadcn/ui with `pnpm dlx shadcn@latest init`. Add components: button, card, input, textarea, badge, scroll-area, toast. Use default theme.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 3,
      "title": "Clean .gitignore",
      "description": "Ensure .gitignore covers: node_modules, .next, .env*.local, *.tsbuildinfo, .DS_Store. Keep ralph files (tickets.json, progress.txt, RALPH.md) tracked.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 4,
      "title": "Zod schemas for ralph files",
      "description": "Create src/lib/schemas.ts with loose Zod schemas. Ticket: id (number), title (string), description (string optional), status (string, default 'pending'), priority (number optional). Use .passthrough() to allow unknown fields. TicketsFile: tickets array. Export types.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 5,
      "title": "Setup tRPC with file system access",
      "description": "Install @trpc/server, @trpc/client, @trpc/react-query, @tanstack/react-query, superjson. Create src/server/trpc.ts router, src/app/api/trpc/[trpc]/route.ts handler. Add tRPC provider to layout. Use RALPH_DIR env var (default cwd) for target directory.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 6,
      "title": "tRPC procedures for tickets CRUD",
      "description": "In src/server/routers/tickets.ts: list() - read/parse tickets.json with zod schema; get(id) - single ticket; create(title, description?, priority?) - add ticket with next id; update(id, data) - partial update; delete(id) - remove ticket. All write back to tickets.json.",
      "status": "completed",
      "priority": 4
    },
    {
      "id": 7,
      "title": "tRPC procedure for progress.txt",
      "description": "In src/server/routers/progress.ts: read() - return progress.txt content as string; Returns empty string if file missing.",
      "status": "completed",
      "priority": 4
    },
    {
      "id": 8,
      "title": "Ticket list view component",
      "description": "Create src/components/TicketList.tsx. Fetch tickets via tRPC. Show cards with title, status badge (color-coded), priority. Click to expand/select. Show empty state if no tickets.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 9,
      "title": "Add ticket form",
      "description": "Create src/components/AddTicketForm.tsx. Fields: title (required), description (textarea), priority (number input, default 1). Submit via tRPC mutation. Clear form on success, show toast.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 10,
      "title": "Edit ticket functionality",
      "description": "Add edit mode to ticket detail/card. Inline editing or modal. Can edit title, description, priority, status. Save via tRPC update mutation.",
      "status": "completed",
      "priority": 6
    },
    {
      "id": 11,
      "title": "Delete ticket functionality",
      "description": "Add delete button to tickets. Confirmation dialog before delete. Call tRPC delete mutation. Show toast on success.",
      "status": "completed",
      "priority": 6
    },
    {
      "id": 12,
      "title": "Progress.txt viewer component",
      "description": "Create src/components/ProgressViewer.tsx. Fetch content via tRPC. Render as markdown or preformatted text. Use scroll-area, auto-scroll to bottom option.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 13,
      "title": "SSE endpoint for file watching",
      "description": "Create src/app/api/watch/route.ts SSE endpoint. Use chokidar to watch tickets.json and progress.txt in RALPH_DIR. Send events on file changes. Client reconnects on disconnect.",
      "status": "completed",
      "priority": 7
    },
    {
      "id": 14,
      "title": "Live updates via SSE",
      "description": "Create useFileWatch hook that connects to SSE endpoint. On 'tickets' event, invalidate tickets query. On 'progress' event, invalidate progress query. Show connection status indicator.",
      "status": "completed",
      "priority": 8
    },
    {
      "id": 15,
      "title": "Status filtering",
      "description": "Add filter controls to ticket list. Filter by status (all, pending, in_progress, completed, failed). Could be tabs or dropdown. Persist filter in URL params.",
      "status": "completed",
      "priority": 9
    },
    {
      "id": 16,
      "title": "Execute ralph commands from UI",
      "description": "Add 'Run Next Ticket' and 'Run All' buttons. tRPC procedure that spawns `ralph-once` or `ralph` in RALPH_DIR. Return immediately (fire-and-forget). File watcher will pick up changes.",
      "status": "completed",
      "priority": 9
    },
    {
      "id": 17,
      "title": "Desktop notifications",
      "description": "Request notification permission on load. When SSE detects ticket status change to 'completed' or 'failed', show desktop notification with ticket title. Only if tab not focused.",
      "status": "completed",
      "priority": 10
    },
    {
      "id": 18,
      "title": "Main page layout",
      "description": "Design src/app/page.tsx layout. Split view: ticket list on left, detail/progress on right. Or tabs. Header with project path display. Responsive for smaller screens.",
      "status": "completed",
      "priority": 4
    },
    {
      "id": 19,
      "title": "Multi-project support",
      "description": "Add project switcher. Store list of project paths in localStorage. Dropdown to switch RALPH_DIR. Add/remove projects. Each project remembers its own filter state.",
      "status": "completed",
      "priority": 99
    },
    {
      "id": 23,
      "title": "Fix useSyncExternalStore infinite loop in useProjects",
      "description": "Bug: getProjectsSnapshot() calls getProjects() which returns a new array reference each time (from JSON.parse). React sees different reference, re-renders, infinite loop. Fix: cache projects at module level. Add `let projectsCache: Project[] = EMPTY_PROJECTS`. getProjectsSnapshot() returns projectsCache. Create refreshCache() that calls `projectsCache = getProjects()` then notifySubscribers(). All mutation functions (addProject, removeProject, setActiveProject) call refreshCache() instead of notifySubscribers(). Initialize cache on first client-side read. Write a test in src/hooks/use-projects.test.ts that renders the useProjects hook using @testing-library/react renderHook(). The test should verify no errors are thrown and that calling the hook multiple times returns stable references. Run `pnpm test` to verify the fix.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 24,
      "title": "Fix hydration mismatch in useNotifications isSupported",
      "description": "Bug: In src/hooks/use-notifications.ts line 133, `isSupported` is computed as `typeof window !== 'undefined' && 'Notification' in window`. This is false on server, true on client, causing hydration mismatch in ConnectionStatusIndicator when notificationIndicator span renders on client but not server. Fix: Change isSupported to use useState + useEffect pattern. Initialize as `const [isSupported, setIsSupported] = useState(false)`, then in a useEffect set `setIsSupported('Notification' in window)`. This ensures server and initial client render both have isSupported=false, then client updates after mount. Test by loading the page and verifying no hydration mismatch warning in console.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 25,
      "title": "ProcessRunner interface and types",
      "description": "Create src/lib/process-runner.ts with types: ProcessHandle { id: string; pid: number }, ProcessStatus (discriminated union: { state: 'running'; pid: number } | { state: 'exited'; code: number | null } | { state: 'not_found' }), ProcessOutputLine { stream: 'stdout' | 'stderr'; line: string; timestamp: number }. Define ProcessRunner interface: start(opts: { command: string; cwd: string }) => Promise<Result<ProcessHandle, Error>>, getStatus(id: string) => ProcessStatus, kill(id: string) => Promise<Result<void, Error>>, onOutput(id: string, cb: (line: ProcessOutputLine) => void) => () => void, listRunning() => ProcessHandle[]. Write unit tests for type guards (isRunning, isExited, etc).",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 26,
      "title": "ProcessRunner implementation",
      "description": "Create src/server/services/process-runner.ts implementing ProcessRunner interface. Use child_process.spawn with stdio: 'pipe'. Store running processes in Map<string, { child: ChildProcess; output: ProcessOutputLine[] }>. Generate unique id (nanoid or uuid). On spawn: attach stdout/stderr listeners, push lines to output array, call registered callbacks. On exit: update status, store exit code. Implement getStatus by checking if process exists and child.exitCode. Implement kill with child.kill(). Implement onOutput by storing callbacks in a Set per process. Write integration tests that spawn a real process (like 'echo hello') and verify output is captured and status transitions work.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 27,
      "title": "tRPC procedures for ProcessRunner",
      "description": "Create src/server/routers/process.ts. Import ProcessRunner instance. Procedures: start(command: string) - calls runner.start with ctx.ralphDir, returns handle or error; status(id: string) - returns ProcessStatus; kill(id: string) - kills process; list() - returns all running handles. Inject ProcessRunner via module-level instance for now (can refactor to DI later). Write tests with a mock ProcessRunner that returns canned responses. Verify each procedure calls the right runner method with right args.",
      "status": "completed",
      "priority": 4
    },
    {
      "id": 28,
      "title": "SSE endpoint for process output streaming",
      "description": "Create src/app/api/process/[id]/stream/route.ts SSE endpoint. Takes process id from params. Calls runner.onOutput(id, ...) to subscribe. Streams ProcessOutputLine as SSE events (event: 'output', data: JSON). On process exit, send event: 'exit' with code, then close stream. Handle client disconnect by unsubscribing. Write test that starts a process, connects to SSE, verifies output events arrive.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 29,
      "title": "useProcessOutput hook",
      "description": "Create src/hooks/use-process-output.ts. Hook takes processId. Connects to SSE endpoint /api/process/[id]/stream. Accumulates output lines in state. Returns { lines: ProcessOutputLine[], isConnected: boolean, exitCode: number | null }. Cleans up SSE connection on unmount or id change. Write test with mock SSE (or integration test with real endpoint).",
      "status": "completed",
      "priority": 6
    },
    {
      "id": 30,
      "title": "ProcessOutputViewer component",
      "description": "Create src/components/ProcessOutputViewer.tsx. Takes processId prop. Uses useProcessOutput hook. Renders output lines in scroll-area with monospace font. stdout in default color, stderr in red. Auto-scroll to bottom (with toggle). Shows 'Process exited with code X' when done. Shows connecting/disconnected state. Write component test that mocks the hook and verifies rendering.",
      "status": "completed",
      "priority": 7
    },
    {
      "id": 31,
      "title": "Update RalphControls to use ProcessRunner",
      "description": "Refactor src/components/RalphControls.tsx. Replace fire-and-forget mutations with new process.start. On click: call start mutation, store returned processId in state. Show 'Running...' with spinner while process active. Poll or subscribe to status. Show ProcessOutputViewer in a collapsible panel or modal. Add 'Stop' button that calls kill. When process exits, show result (success/failure). Clear state to allow running again. Test by mocking tRPC and verifying correct calls and state transitions.",
      "status": "completed",
      "priority": 8
    },
    {
      "id": 32,
      "title": "Remove old fire-and-forget ralph router",
      "description": "Delete or replace src/server/routers/ralph.ts now that ProcessRunner handles execution. Update router index to use new process router. Verify RalphControls works end-to-end. Clean up any unused imports.",
      "status": "completed",
      "priority": 9
    },
    {
      "id": 33,
      "title": "Support RALPH_BIN env var for ralph commands",
      "description": "The process runner calls `ralph` and `ralph-once` directly, but these may not be in PATH. Fix: Read RALPH_BIN env var (path to ralph bin directory). In process-runner.ts start(), if RALPH_BIN is set and command starts with 'ralph', prepend RALPH_BIN to the command path. E.g., `ralph-once` becomes `${RALPH_BIN}/ralph-once`. Add RALPH_BIN to .env.example with a comment. Test by setting RALPH_BIN and verifying ralph commands run.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 34,
      "title": "Validate required env vars on startup",
      "description": "Create src/lib/env.ts that validates important env vars exist on server startup. Check for RALPH_BIN (required). Use Zod to parse process.env with clear error messages. Export typed env object. Import in src/server/trpc.ts or a server-side layout to ensure it runs early. If missing, throw with helpful message like 'Missing RALPH_BIN - set path to ralph bin directory'. Add test that verifies validation works.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 35,
      "title": "Say hi",
      "description": "No-op ticket. Just say 'Hello!' in progress.txt and mark complete. Don't change any code.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 36,
      "title": "Fix file watcher query invalidation with IoC",
      "description": "Bug: useFileWatch uses raw queryClient.invalidateQueries() with manually constructed keys like [['progress']] which don't match tRPC's internal key format. Progress updates don't trigger re-fetch. Fix: Invert control - useFileWatch should accept callbacks for invalidation instead of doing it directly. Change interface to accept onTicketsChange and onProgressChange callbacks. The component using the hook (ConnectionStatusIndicator or wherever) passes in functions that call utils.tickets.list.invalidate() and utils.progress.read.invalidate() respectively. Remove queryClient usage from the hook. Test by running ralph and verifying progress.txt updates appear without refresh.",
      "status": "in_progress",
      "priority": 1
    },
    {
      "id": 37,
      "title": "Side panel UX for ralph controls and output",
      "description": "Redesign ralph controls UX. Create a persistent side panel (right side) that contains: 1) Run Next Ticket and Run All buttons always visible at top, 2) Stop/Cancel button appears when process is running, 3) ProcessOutputViewer below buttons showing real-time output, 4) Panel should be ~300-400px wide or resizable. Move RalphControls out of header into this side panel. The main content area (tickets list, progress viewer) gets the remaining width. Consider making the panel collapsible. Update page.tsx layout to accommodate side panel.",
      "status": "pending",
      "priority": 2
    }
  ]
}
