{
  "tickets": [
    {
      "id": 1,
      "title": "Init Next.js project with pnpm",
      "description": "Create Next.js 14 app with App Router, TypeScript, pnpm. Use `pnpm create next-app@latest ralph-watch-ui --typescript --tailwind --eslint --app --src-dir --import-alias '@/*'`. Move contents up if nested.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 20,
      "title": "ESLint + Prettier + strict TS + quality check",
      "description": "Install prettier, eslint-config-prettier, eslint-plugin-prettier, lodash, @types/lodash. Create .prettierrc (singleQuote, semi, tabWidth 2). Update .eslintrc to extend prettier. Enable noUncheckedIndexedAccess in tsconfig.json compilerOptions. Add scripts: `format`, `lint`, `typecheck` (tsc --noEmit), `check` (runs all). `pnpm check` must pass after every ticket.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 21,
      "title": "Result type utilities for railway-oriented flow",
      "description": "Create src/lib/result.ts with Result<T, E> type (ok/err discriminated union). Helper functions: ok(value), err(error), isOk(), isErr(), map(), flatMap(), mapErr(). Use for fallible operations instead of throwing.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 22,
      "title": "Test setup with vitest",
      "description": "Install vitest, @testing-library/react, @testing-library/dom. Configure vitest.config.ts. Add `test` script to package.json. Add `test` to the `check` script. Create example integration test for a tRPC endpoint once available.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 2,
      "title": "Add shadcn/ui and configure",
      "description": "Install shadcn/ui with `pnpm dlx shadcn@latest init`. Add components: button, card, input, textarea, badge, scroll-area, toast. Use default theme.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 3,
      "title": "Clean .gitignore",
      "description": "Ensure .gitignore covers: node_modules, .next, .env*.local, *.tsbuildinfo, .DS_Store. Keep ralph files (tickets.json, progress.txt, RALPH.md) tracked.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 4,
      "title": "Zod schemas for ralph files",
      "description": "Create src/lib/schemas.ts with loose Zod schemas. Ticket: id (number), title (string), description (string optional), status (string, default 'pending'), priority (number optional). Use .passthrough() to allow unknown fields. TicketsFile: tickets array. Export types.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 5,
      "title": "Setup tRPC with file system access",
      "description": "Install @trpc/server, @trpc/client, @trpc/react-query, @tanstack/react-query, superjson. Create src/server/trpc.ts router, src/app/api/trpc/[trpc]/route.ts handler. Add tRPC provider to layout. Use RALPH_DIR env var (default cwd) for target directory.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 6,
      "title": "tRPC procedures for tickets CRUD",
      "description": "In src/server/routers/tickets.ts: list() - read/parse tickets.json with zod schema; get(id) - single ticket; create(title, description?, priority?) - add ticket with next id; update(id, data) - partial update; delete(id) - remove ticket. All write back to tickets.json.",
      "status": "completed",
      "priority": 4
    },
    {
      "id": 7,
      "title": "tRPC procedure for progress.txt",
      "description": "In src/server/routers/progress.ts: read() - return progress.txt content as string; Returns empty string if file missing.",
      "status": "completed",
      "priority": 4
    },
    {
      "id": 8,
      "title": "Ticket list view component",
      "description": "Create src/components/TicketList.tsx. Fetch tickets via tRPC. Show cards with title, status badge (color-coded), priority. Click to expand/select. Show empty state if no tickets.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 9,
      "title": "Add ticket form",
      "description": "Create src/components/AddTicketForm.tsx. Fields: title (required), description (textarea), priority (number input, default 1). Submit via tRPC mutation. Clear form on success, show toast.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 10,
      "title": "Edit ticket functionality",
      "description": "Add edit mode to ticket detail/card. Inline editing or modal. Can edit title, description, priority, status. Save via tRPC update mutation.",
      "status": "completed",
      "priority": 6
    },
    {
      "id": 11,
      "title": "Delete ticket functionality",
      "description": "Add delete button to tickets. Confirmation dialog before delete. Call tRPC delete mutation. Show toast on success.",
      "status": "completed",
      "priority": 6
    },
    {
      "id": 12,
      "title": "Progress.txt viewer component",
      "description": "Create src/components/ProgressViewer.tsx. Fetch content via tRPC. Render as markdown or preformatted text. Use scroll-area, auto-scroll to bottom option.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 13,
      "title": "SSE endpoint for file watching",
      "description": "Create src/app/api/watch/route.ts SSE endpoint. Use chokidar to watch tickets.json and progress.txt in RALPH_DIR. Send events on file changes. Client reconnects on disconnect.",
      "status": "completed",
      "priority": 7
    },
    {
      "id": 14,
      "title": "Live updates via SSE",
      "description": "Create useFileWatch hook that connects to SSE endpoint. On 'tickets' event, invalidate tickets query. On 'progress' event, invalidate progress query. Show connection status indicator.",
      "status": "completed",
      "priority": 8
    },
    {
      "id": 15,
      "title": "Status filtering",
      "description": "Add filter controls to ticket list. Filter by status (all, pending, in_progress, completed, failed). Could be tabs or dropdown. Persist filter in URL params.",
      "status": "completed",
      "priority": 9
    },
    {
      "id": 16,
      "title": "Execute ralph commands from UI",
      "description": "Add 'Run Next Ticket' and 'Run All' buttons. tRPC procedure that spawns `ralph-once` or `ralph` in RALPH_DIR. Return immediately (fire-and-forget). File watcher will pick up changes.",
      "status": "completed",
      "priority": 9
    },
    {
      "id": 17,
      "title": "Desktop notifications",
      "description": "Request notification permission on load. When SSE detects ticket status change to 'completed' or 'failed', show desktop notification with ticket title. Only if tab not focused.",
      "status": "completed",
      "priority": 10
    },
    {
      "id": 18,
      "title": "Main page layout",
      "description": "Design src/app/page.tsx layout. Split view: ticket list on left, detail/progress on right. Or tabs. Header with project path display. Responsive for smaller screens.",
      "status": "completed",
      "priority": 4
    },
    {
      "id": 19,
      "title": "Multi-project support",
      "description": "Add project switcher. Store list of project paths in localStorage. Dropdown to switch RALPH_DIR. Add/remove projects. Each project remembers its own filter state.",
      "status": "completed",
      "priority": 99
    },
    {
      "id": 23,
      "title": "Fix useSyncExternalStore infinite loop in useProjects",
      "description": "Bug: getProjectsSnapshot() calls getProjects() which returns a new array reference each time (from JSON.parse). React sees different reference, re-renders, infinite loop. Fix: cache projects at module level. Add `let projectsCache: Project[] = EMPTY_PROJECTS`. getProjectsSnapshot() returns projectsCache. Create refreshCache() that calls `projectsCache = getProjects()` then notifySubscribers(). All mutation functions (addProject, removeProject, setActiveProject) call refreshCache() instead of notifySubscribers(). Initialize cache on first client-side read. Write a test in src/hooks/use-projects.test.ts that renders the useProjects hook using @testing-library/react renderHook(). The test should verify no errors are thrown and that calling the hook multiple times returns stable references. Run `pnpm test` to verify the fix.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 24,
      "title": "Fix hydration mismatch in useNotifications isSupported",
      "description": "Bug: In src/hooks/use-notifications.ts line 133, `isSupported` is computed as `typeof window !== 'undefined' && 'Notification' in window`. This is false on server, true on client, causing hydration mismatch in ConnectionStatusIndicator when notificationIndicator span renders on client but not server. Fix: Change isSupported to use useState + useEffect pattern. Initialize as `const [isSupported, setIsSupported] = useState(false)`, then in a useEffect set `setIsSupported('Notification' in window)`. This ensures server and initial client render both have isSupported=false, then client updates after mount. Test by loading the page and verifying no hydration mismatch warning in console.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 25,
      "title": "ProcessRunner interface and types",
      "description": "Create src/lib/process-runner.ts with types: ProcessHandle { id: string; pid: number }, ProcessStatus (discriminated union: { state: 'running'; pid: number } | { state: 'exited'; code: number | null } | { state: 'not_found' }), ProcessOutputLine { stream: 'stdout' | 'stderr'; line: string; timestamp: number }. Define ProcessRunner interface: start(opts: { command: string; cwd: string }) => Promise<Result<ProcessHandle, Error>>, getStatus(id: string) => ProcessStatus, kill(id: string) => Promise<Result<void, Error>>, onOutput(id: string, cb: (line: ProcessOutputLine) => void) => () => void, listRunning() => ProcessHandle[]. Write unit tests for type guards (isRunning, isExited, etc).",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 26,
      "title": "ProcessRunner implementation",
      "description": "Create src/server/services/process-runner.ts implementing ProcessRunner interface. Use child_process.spawn with stdio: 'pipe'. Store running processes in Map<string, { child: ChildProcess; output: ProcessOutputLine[] }>. Generate unique id (nanoid or uuid). On spawn: attach stdout/stderr listeners, push lines to output array, call registered callbacks. On exit: update status, store exit code. Implement getStatus by checking if process exists and child.exitCode. Implement kill with child.kill(). Implement onOutput by storing callbacks in a Set per process. Write integration tests that spawn a real process (like 'echo hello') and verify output is captured and status transitions work.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 27,
      "title": "tRPC procedures for ProcessRunner",
      "description": "Create src/server/routers/process.ts. Import ProcessRunner instance. Procedures: start(command: string) - calls runner.start with ctx.ralphDir, returns handle or error; status(id: string) - returns ProcessStatus; kill(id: string) - kills process; list() - returns all running handles. Inject ProcessRunner via module-level instance for now (can refactor to DI later). Write tests with a mock ProcessRunner that returns canned responses. Verify each procedure calls the right runner method with right args.",
      "status": "completed",
      "priority": 4
    },
    {
      "id": 28,
      "title": "SSE endpoint for process output streaming",
      "description": "Create src/app/api/process/[id]/stream/route.ts SSE endpoint. Takes process id from params. Calls runner.onOutput(id, ...) to subscribe. Streams ProcessOutputLine as SSE events (event: 'output', data: JSON). On process exit, send event: 'exit' with code, then close stream. Handle client disconnect by unsubscribing. Write test that starts a process, connects to SSE, verifies output events arrive.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 29,
      "title": "useProcessOutput hook",
      "description": "Create src/hooks/use-process-output.ts. Hook takes processId. Connects to SSE endpoint /api/process/[id]/stream. Accumulates output lines in state. Returns { lines: ProcessOutputLine[], isConnected: boolean, exitCode: number | null }. Cleans up SSE connection on unmount or id change. Write test with mock SSE (or integration test with real endpoint).",
      "status": "completed",
      "priority": 6
    },
    {
      "id": 30,
      "title": "ProcessOutputViewer component",
      "description": "Create src/components/ProcessOutputViewer.tsx. Takes processId prop. Uses useProcessOutput hook. Renders output lines in scroll-area with monospace font. stdout in default color, stderr in red. Auto-scroll to bottom (with toggle). Shows 'Process exited with code X' when done. Shows connecting/disconnected state. Write component test that mocks the hook and verifies rendering.",
      "status": "completed",
      "priority": 7
    },
    {
      "id": 31,
      "title": "Update RalphControls to use ProcessRunner",
      "description": "Refactor src/components/RalphControls.tsx. Replace fire-and-forget mutations with new process.start. On click: call start mutation, store returned processId in state. Show 'Running...' with spinner while process active. Poll or subscribe to status. Show ProcessOutputViewer in a collapsible panel or modal. Add 'Stop' button that calls kill. When process exits, show result (success/failure). Clear state to allow running again. Test by mocking tRPC and verifying correct calls and state transitions.",
      "status": "completed",
      "priority": 8
    },
    {
      "id": 32,
      "title": "Remove old fire-and-forget ralph router",
      "description": "Delete or replace src/server/routers/ralph.ts now that ProcessRunner handles execution. Update router index to use new process router. Verify RalphControls works end-to-end. Clean up any unused imports.",
      "status": "completed",
      "priority": 9
    },
    {
      "id": 33,
      "title": "Support RALPH_BIN env var for ralph commands",
      "description": "The process runner calls `ralph` and `ralph-once` directly, but these may not be in PATH. Fix: Read RALPH_BIN env var (path to ralph bin directory). In process-runner.ts start(), if RALPH_BIN is set and command starts with 'ralph', prepend RALPH_BIN to the command path. E.g., `ralph-once` becomes `${RALPH_BIN}/ralph-once`. Add RALPH_BIN to .env.example with a comment. Test by setting RALPH_BIN and verifying ralph commands run.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 34,
      "title": "Validate required env vars on startup",
      "description": "Create src/lib/env.ts that validates important env vars exist on server startup. Check for RALPH_BIN (required). Use Zod to parse process.env with clear error messages. Export typed env object. Import in src/server/trpc.ts or a server-side layout to ensure it runs early. If missing, throw with helpful message like 'Missing RALPH_BIN - set path to ralph bin directory'. Add test that verifies validation works.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 35,
      "title": "Say hi",
      "description": "No-op ticket. Just say 'Hello!' in progress.txt and mark complete. Don't change any code.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 36,
      "title": "Fix file watcher query invalidation with IoC",
      "description": "Bug: useFileWatch uses raw queryClient.invalidateQueries() with manually constructed keys like [['progress']] which don't match tRPC's internal key format. Progress updates don't trigger re-fetch. Fix: Invert control - useFileWatch should accept callbacks for invalidation instead of doing it directly. Change interface to accept onTicketsChange and onProgressChange callbacks. The component using the hook (ConnectionStatusIndicator or wherever) passes in functions that call utils.tickets.list.invalidate() and utils.progress.read.invalidate() respectively. Remove queryClient usage from the hook. Test by running ralph and verifying progress.txt updates appear without refresh.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 37,
      "title": "Side panel UX for ralph controls and output",
      "description": "Redesign ralph controls UX. Create a persistent side panel (right side) that contains: 1) Run Next Ticket and Run All buttons always visible at top, 2) Stop/Cancel button appears when process is running, 3) ProcessOutputViewer below buttons showing real-time output, 4) Panel should be ~300-400px wide or resizable. Move RalphControls out of header into this side panel. The main content area (tickets list, progress viewer) gets the remaining width. Consider making the panel collapsible. Update page.tsx layout to accommodate side panel.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 38,
      "title": "Consolidate status badge utilities",
      "description": "Extract duplicated getStatusBadgeClass() and formatStatus() functions from src/app/page.tsx and src/components/TicketList.tsx into src/lib/ticket-ui.ts. Update both files to import from the shared module. Run pnpm check to verify.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 39,
      "title": "Clean up comments per style guide",
      "description": "Audit all source files for comments. Remove: comments that restate what code does, imperative comments explaining history ('added for X', 'fixed bug where Y'), TODO comments for completed work. Keep: comments providing context on purpose, explaining non-obvious design decisions. If variable/function name is clear, no comment needed. Run pnpm check after.",
      "status": "completed",
      "priority": 4
    },
    {
      "id": 40,
      "title": "Add process output ring buffer",
      "description": "ProcessRunner buffers ALL output lines forever - memory leak for long processes. Fix: Add MAX_OUTPUT_LINES = 5000 constant. When pushing to output array, if length exceeds max, shift oldest. Run pnpm check after.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 41,
      "title": "Add onExit callback to ProcessRunner",
      "description": "SSE endpoint polls every 100ms for process exit - wasteful. Fix: Add onExit(id, callback) to ProcessRunner interface. Store exit callbacks in Map, fire from child.on('exit'). Update /api/process/[id]/stream to use onExit instead of setInterval. Run pnpm check after.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 42,
      "title": "URL-based project routing",
      "description": "ARCHITECTURAL REFACTOR: Replace localStorage/context project management with URL-based routing.\n\n## Why\nCurrent flow is 5 layers: localStorage → ProjectProvider → useProjectContext → TRPCProvider header → server ctx. Complex, causes hydration issues, not bookmarkable.\n\n## Target Architecture\n- URL structure: /project/[encodedPath]/ where encodedPath is base64url of absolute path\n- Project available everywhere via Next.js params - no context needed\n- React Query keys naturally scoped per-project (different URL = different cache)\n- SSE endpoints get project from URL\n\n## Implementation Steps\n1. Create src/lib/project-path.ts with encodeProjectPath()/decodeProjectPath() helpers (base64url)\n2. Create src/app/project/[path]/page.tsx - move current page.tsx content here, get project from params\n3. Create src/app/project/[path]/layout.tsx - wrap with TRPCProvider, pass project to context\n4. Update src/app/page.tsx to be project picker: list recent projects (from cookie), link to add new\n5. Update src/server/trpc.ts context creation - read project from x-ralph-dir header OR from request URL\n6. Update TRPCProvider - remove header logic, project comes from URL now\n7. Update SSE endpoints (/api/watch, /api/process/[id]/stream) - read project from query param ?dir=\n8. Update useFileWatch - pass project as param instead of reading from context\n9. Delete: ProjectProvider.tsx, useProjectContext references, localStorage project logic in projects.ts\n10. Add cookie helpers: getRecentProjects(), addRecentProject() for the picker\n\n## Files to Change\n- CREATE: src/app/project/[path]/page.tsx, src/app/project/[path]/layout.tsx, src/lib/project-path.ts\n- MODIFY: src/app/page.tsx (becomes picker), src/server/trpc.ts, TRPCProvider.tsx, useFileWatch.ts, SSE routes\n- DELETE: ProjectProvider.tsx, most of projects.ts\n\n## Data Flow After\nUser navigates to /project/L21udC9kYXRhLy4uLg==/ → Next.js extracts [path] param → decoded in layout → passed to tRPC context → available server-side. No localStorage, no context threading, no hydration mismatch.\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 6
    },
    {
      "id": 43,
      "title": "Unify SSE into single event stream",
      "description": "ARCHITECTURAL REFACTOR: Consolidate /api/watch and /api/process/[id]/stream into single /api/events endpoint. Do this AFTER ticket #42 (URL-based routing).\n\n## Why\nCurrently 2 separate SSE endpoints doing similar things - separate connection management, message formatting, cleanup logic. Client manages 2 EventSource connections.\n\n## Target Architecture\nSingle endpoint: /api/events?project=encodedPath&topics=tickets,progress,process:id1,process:id2\n- Subscribe to multiple topics in one connection\n- All events have shape: {topic: string, type: string, data: any}\n- Topics: 'tickets', 'progress', 'process:{id}'\n- Event types per topic: tickets/progress have 'change', process has 'output'/'exit'\n\n## Implementation Steps\n1. Create src/app/api/events/route.ts - unified SSE endpoint\n   - Parse topics from query param\n   - For 'tickets'/'progress' topics: setup chokidar watcher (reuse logic from /api/watch)\n   - For 'process:id' topics: subscribe via runner.onOutput() and runner.onExit()\n   - Emit events as {topic, type, data} JSON\n   - Handle cleanup on disconnect\n2. Create src/hooks/use-event-stream.ts - unified client hook\n   - Takes: project, topics[] (can be dynamic)\n   - Returns: subscribe(topic, handler) function, connectionStatus\n   - Internally manages single EventSource, dispatches by topic\n3. Update components to use useEventStream instead of useFileWatch/useProcessOutput\n   - ConnectionStatus: subscribe to 'tickets', 'progress'\n   - RalphSidePanel: subscribe to 'process:{id}' when process running\n4. Delete old endpoints and hooks:\n   - DELETE: /api/watch/route.ts, /api/process/[id]/stream/route.ts\n   - DELETE: use-file-watch.ts, use-process-output.ts\n\n## Event Examples\n{topic: 'tickets', type: 'change', data: {file: 'tickets.json'}}\n{topic: 'progress', type: 'change', data: {file: 'progress.txt'}}\n{topic: 'process:abc123', type: 'output', data: {stream: 'stdout', line: '...', timestamp: 123}}\n{topic: 'process:abc123', type: 'exit', data: {code: 0}}\n\n## Result\nClient: 2 connections → 1 connection\nServer: 2 SSE endpoints → 1 endpoint\nHooks: useFileWatch + useProcessOutput → useEventStream\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 7
    },
    {
      "id": 44,
      "title": "Quick-add tickets with draft status",
      "description": "Add ability to create tickets from the UI with a quick-add flow.\n\n## Changes Required\n\n### 1. Add 'draft' to ticket status schema\n- Update src/lib/schemas.ts to include 'draft' in status enum\n- Draft tickets are ignored by ralph (already documented in RALPH.md)\n\n### 2. Quick-add bar component\n- Create src/components/QuickAddBar.tsx\n- Always-visible input bar at bottom of ticket list\n- Type title, Enter to create as draft\n- Shift+Enter to create as pending (ready immediately)\n- Auto-focus stays in input for rapid entry\n- Show subtle '+' button to expand full form\n\n### 3. Wire up AddTicketForm\n- The existing AddTicketForm.tsx is orphaned (never imported)\n- Add status field (draft/pending) to form\n- Use in expanded mode from QuickAddBar\n- Add to project page layout\n\n### 4. Draft ticket UI\n- Show draft tickets dimmed/faded in list\n- Add 'Mark Ready' button to promote draft → pending\n- Filter toggle to show/hide drafts\n\n### 5. Update ticket-ui.ts\n- Add badge styling for draft status (gray/muted)\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 45,
      "title": "Configurable command buttons",
      "description": "Replace hardcoded ralph commands with config-driven buttons.\n\n## Config File\nRead `.ralph-watch.json` from project root (ralphDir). Schema:\n```json\n{\n  \"commands\": [\n    { \"label\": \"Run Next\", \"cmd\": \"ralph-once\", \"icon\": \"play\" },\n    { \"label\": \"Run All\", \"cmd\": \"ralph\", \"icon\": \"zap\" },\n    { \"label\": \"Build\", \"cmd\": \"pnpm build\", \"icon\": \"hammer\" }\n  ]\n}\n```\n\n## Implementation Steps\n\n### 1. Config schema and loader\n- Create src/lib/project-config.ts with Zod schema\n- CommandConfig: { label: string, cmd: string, icon?: string, destructive?: boolean }\n- ProjectConfig: { commands: CommandConfig[] }\n- Default config if file missing: ralph-once + ralph commands\n\n### 2. tRPC endpoint\n- Add config.get procedure in src/server/routers/config.ts\n- Reads .ralph-watch.json from ctx.ralphDir\n- Returns parsed config or defaults\n\n### 3. Update RalphSidePanel\n- Fetch config via tRPC\n- Render command buttons dynamically from config.commands\n- Map icon names to lucide-react icons\n- If destructive: true, show confirmation dialog before running\n\n### 4. Icon mapping\n- Create icon map: { play: PlayIcon, zap: ZapIcon, hammer: HammerIcon, ... }\n- Fallback to TerminalIcon for unknown icons\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 46,
      "title": "Mobile-responsive UI",
      "description": "Make the UI fully usable on mobile devices.\n\n## Layout Strategy\nUse bottom tab navigation on small screens (< 768px).\n\n### Tabs\n1. **Tickets** - Full-width ticket list with cards\n2. **Progress** - Progress.txt viewer\n3. **Run** - Command buttons + process output\n\n### Implementation Steps\n\n#### 1. Bottom tab bar component\n- Create src/components/BottomTabBar.tsx\n- Three tabs: Tickets, Progress, Run\n- Fixed to bottom, thumb-friendly height (56-64px)\n- Active tab indicator\n- Only renders on mobile (hidden on md+ breakpoint)\n\n#### 2. Mobile layout wrapper\n- Create src/components/MobileLayout.tsx\n- Manages active tab state\n- Renders appropriate content based on tab\n- Full-height content area above tab bar\n\n#### 3. Update project page\n- Detect screen size (useMediaQuery or Tailwind responsive)\n- Render MobileLayout on small screens\n- Render current desktop layout on large screens\n\n#### 4. Touch-friendly adjustments\n- Larger tap targets for buttons (min 44px)\n- Ticket cards: full-width, larger text\n- Swipe gestures optional (nice-to-have)\n- Floating action button for quick-add (bottom-right, above tab bar)\n\n#### 5. Process output on mobile\n- In 'Run' tab, commands at top, output below\n- Output area scrollable, auto-scroll to bottom\n- Larger font for readability\n\n### Breakpoints\n- Mobile: < 768px (tabs, single column)\n- Desktop: >= 768px (current layout)\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 47,
      "title": "Fix process output loss on tab switch",
      "description": "BUG: When browser tab is backgrounded, SSE disconnects and process output is lost. ProcessRunner has a ring buffer but it's not replayed on reconnect.\n\n## Root Cause\n1. Browser throttles/disconnects EventSource when tab backgrounded\n2. Process output arrives → stored in ProcessRunner ring buffer\n3. Tab returns → EventSource reconnects\n4. SSE only streams NEW output, doesn't replay buffer\n5. Output during disconnect is lost\n\n## Fix: Replay buffered output on SSE connect\n\n### 1. Add getOutput method to ProcessRunner\n- In src/lib/process-runner.ts interface: `getOutput(id: string): ProcessOutputLine[]`\n- In src/server/services/process-runner.ts: return `record.output` array (the ring buffer)\n\n### 2. Replay buffer on SSE subscription\n- In src/app/api/events/route.ts, when subscribing to `process:{id}` topic:\n- Call `runner.getOutput(processId)` to get buffered lines\n- Send all buffered lines as 'output' events BEFORE subscribing to live stream\n- This replays history on every connect/reconnect\n\n### 3. Add sessionStorage persistence (client-side backup)\n- In RalphSidePanel.tsx: persist `lines` to sessionStorage on each update\n- Key: `ralph-output-${processId}`\n- On mount: restore from sessionStorage if processId matches\n- Clear on process exit or new process start\n\n### 4. Add visibility-aware reconnection\n- Create src/hooks/use-visibility.ts - detects document.visibilityState\n- In use-event-stream.ts: when tab becomes visible and disconnected, reconnect immediately (skip 3s delay)\n\n### 5. Write integration test\n- Test that simulates disconnect/reconnect and verifies output is preserved\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 48,
      "title": "move the quick add input above the ticket list in desktop mode",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 49,
      "title": "add darkmode configuration with system-default setting",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 50,
      "title": "bugfix: when quick add field is submitted, the entry text is not passed to the detailed form entry",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 51,
      "title": "configure the colour schemes to follow catppuccin styles for light and dark mode",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 52,
      "title": "Refactor RalphSidePanel to state machine + server reconciliation",
      "description": "ARCHITECTURE: Replace fragile useState/useEffect coordination with state machine pattern.\n\n## Problem\nCurrent RalphSidePanel uses multiple useState hooks (`runningProcess`, `processExitCode`, `lines`) coordinated by useEffects. This creates race conditions:\n- Exit event can arrive but state not cleared due to guard conditions\n- SSE disconnect loses events, client stuck showing 'Stop' button\n- 'Process not found' error events ignored\n- No recovery mechanism on reconnect\n\n## Solution: State Machine + Server Reconciliation\n\n### 1. Define process state machine\nCreate src/lib/process-state.ts:\n```typescript\ntype ProcessState =\n  | { status: 'idle' }\n  | { status: 'starting', command: string }\n  | { status: 'running', id: string, pid: number, lines: ProcessOutputLine[] }\n  | { status: 'exiting', id: string, lines: ProcessOutputLine[] }\n  | { status: 'completed', id: string, exitCode: number | null, lines: ProcessOutputLine[] };\n\ntype ProcessAction =\n  | { type: 'START', command: string }\n  | { type: 'STARTED', id: string, pid: number }\n  | { type: 'OUTPUT', id: string, line: ProcessOutputLine }\n  | { type: 'EXIT', id: string, code: number | null }\n  | { type: 'ERROR', id: string, message: string }\n  | { type: 'RESET' }\n  | { type: 'RECONCILE', serverState: 'running' | 'exited' | 'not_found', exitCode?: number | null };\n\nfunction processReducer(state: ProcessState, action: ProcessAction): ProcessState {\n  // Explicit transitions only - invalid actions are no-ops\n  switch (state.status) {\n    case 'idle':\n      if (action.type === 'START') return { status: 'starting', command: action.command };\n      break;\n    case 'starting':\n      if (action.type === 'STARTED') return { status: 'running', id: action.id, pid: action.pid, lines: [] };\n      if (action.type === 'ERROR') return { status: 'idle' };\n      break;\n    case 'running':\n      if (action.type === 'OUTPUT' && action.id === state.id)\n        return { ...state, lines: [...state.lines, action.line] };\n      if (action.type === 'EXIT' && action.id === state.id)\n        return { status: 'completed', id: state.id, exitCode: action.code, lines: state.lines };\n      if (action.type === 'RECONCILE' && action.serverState !== 'running')\n        return { status: 'completed', id: state.id, exitCode: action.exitCode ?? null, lines: state.lines };\n      break;\n    case 'completed':\n      if (action.type === 'RESET') return { status: 'idle' };\n      if (action.type === 'START') return { status: 'starting', command: action.command };\n      break;\n  }\n  return state; // Invalid transition - no-op\n}\n```\n\n### 2. Add onReconnect callback to useEventStream\nIn src/hooks/use-event-stream.ts:\n- Add `onReconnect?: () => void` to options\n- Call it when EventSource reconnects after disconnect\n- This triggers reconciliation\n\n### 3. Refactor RalphSidePanel to use reducer\nReplace useState hooks with single useReducer. SSE events dispatch actions. UI state derived from reducer state.\n\n### 4. Server reconciliation on reconnect\nWhen SSE reconnects, query `trpc.process.status` and dispatch RECONCILE action if server state differs from client.\n\n### 5. Handle 'error' events from SSE\nIn use-event-stream.ts, when type is 'error' for a process topic, treat as exit with null code.\n\n### 6. Write tests\n- Unit test processReducer transitions\n- Test SSE disconnect/reconnect reconciliation\n- Test invalid transitions are no-ops\n- Test rapid start/stop doesn't corrupt state\n\n## Benefits\n- Impossible states are impossible\n- All transitions explicit and testable\n- Server reconciliation handles edge cases\n- No useEffect coordination mess\n- Single source of truth (the reducer)\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 53,
      "title": "use streamdown library to display description block in main pane, not in ticket view",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 54,
      "title": "add a new \"Incomplete\" tab that displays draft, pending, and In Progress tickets, and make that the default",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 55,
      "title": "use streamdown on the progress log display",
      "status": "in_progress",
      "priority": 12
    },
    {
      "id": 56,
      "title": "fix selected tab styling",
      "description": "remember that border highlights can be cut off by the parent container if the element is already full width/height. a selection border is useful, but need to not look broken and cutoff",
      "status": "pending",
      "priority": 13
    },
    {
      "id": 57,
      "title": "add a ralph control button to follow an existing ralph instance",
      "status": "pending",
      "priority": 14
    },
    {
      "id": 58,
      "title": "move progress log to dedicated page/tab, with scroll-to-bottom and scroll-to-top buttons floating in the bottom right",
      "status": "pending",
      "priority": 133
    }
  ]
}
