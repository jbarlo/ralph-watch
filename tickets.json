{
  "tickets": [
    {
      "id": 1,
      "title": "Init Next.js project with pnpm",
      "description": "Create Next.js 14 app with App Router, TypeScript, pnpm. Use `pnpm create next-app@latest ralph-watch-ui --typescript --tailwind --eslint --app --src-dir --import-alias '@/*'`. Move contents up if nested.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 20,
      "title": "ESLint + Prettier + strict TS + quality check",
      "description": "Install prettier, eslint-config-prettier, eslint-plugin-prettier, lodash, @types/lodash. Create .prettierrc (singleQuote, semi, tabWidth 2). Update .eslintrc to extend prettier. Enable noUncheckedIndexedAccess in tsconfig.json compilerOptions. Add scripts: `format`, `lint`, `typecheck` (tsc --noEmit), `check` (runs all). `pnpm check` must pass after every ticket.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 21,
      "title": "Result type utilities for railway-oriented flow",
      "description": "Create src/lib/result.ts with Result<T, E> type (ok/err discriminated union). Helper functions: ok(value), err(error), isOk(), isErr(), map(), flatMap(), mapErr(). Use for fallible operations instead of throwing.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 22,
      "title": "Test setup with vitest",
      "description": "Install vitest, @testing-library/react, @testing-library/dom. Configure vitest.config.ts. Add `test` script to package.json. Add `test` to the `check` script. Create example integration test for a tRPC endpoint once available.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 2,
      "title": "Add shadcn/ui and configure",
      "description": "Install shadcn/ui with `pnpm dlx shadcn@latest init`. Add components: button, card, input, textarea, badge, scroll-area, toast. Use default theme.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 3,
      "title": "Clean .gitignore",
      "description": "Ensure .gitignore covers: node_modules, .next, .env*.local, *.tsbuildinfo, .DS_Store. Keep ralph files (tickets.json, progress.txt, RALPH.md) tracked.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 4,
      "title": "Zod schemas for ralph files",
      "description": "Create src/lib/schemas.ts with loose Zod schemas. Ticket: id (number), title (string), description (string optional), status (string, default 'pending'), priority (number optional). Use .passthrough() to allow unknown fields. TicketsFile: tickets array. Export types.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 5,
      "title": "Setup tRPC with file system access",
      "description": "Install @trpc/server, @trpc/client, @trpc/react-query, @tanstack/react-query, superjson. Create src/server/trpc.ts router, src/app/api/trpc/[trpc]/route.ts handler. Add tRPC provider to layout. Use RALPH_DIR env var (default cwd) for target directory.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 6,
      "title": "tRPC procedures for tickets CRUD",
      "description": "In src/server/routers/tickets.ts: list() - read/parse tickets.json with zod schema; get(id) - single ticket; create(title, description?, priority?) - add ticket with next id; update(id, data) - partial update; delete(id) - remove ticket. All write back to tickets.json.",
      "status": "completed",
      "priority": 4
    },
    {
      "id": 7,
      "title": "tRPC procedure for progress.txt",
      "description": "In src/server/routers/progress.ts: read() - return progress.txt content as string; Returns empty string if file missing.",
      "status": "completed",
      "priority": 4
    },
    {
      "id": 8,
      "title": "Ticket list view component",
      "description": "Create src/components/TicketList.tsx. Fetch tickets via tRPC. Show cards with title, status badge (color-coded), priority. Click to expand/select. Show empty state if no tickets.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 9,
      "title": "Add ticket form",
      "description": "Create src/components/AddTicketForm.tsx. Fields: title (required), description (textarea), priority (number input, default 1). Submit via tRPC mutation. Clear form on success, show toast.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 10,
      "title": "Edit ticket functionality",
      "description": "Add edit mode to ticket detail/card. Inline editing or modal. Can edit title, description, priority, status. Save via tRPC update mutation.",
      "status": "completed",
      "priority": 6
    },
    {
      "id": 11,
      "title": "Delete ticket functionality",
      "description": "Add delete button to tickets. Confirmation dialog before delete. Call tRPC delete mutation. Show toast on success.",
      "status": "completed",
      "priority": 6
    },
    {
      "id": 12,
      "title": "Progress.txt viewer component",
      "description": "Create src/components/ProgressViewer.tsx. Fetch content via tRPC. Render as markdown or preformatted text. Use scroll-area, auto-scroll to bottom option.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 13,
      "title": "SSE endpoint for file watching",
      "description": "Create src/app/api/watch/route.ts SSE endpoint. Use chokidar to watch tickets.json and progress.txt in RALPH_DIR. Send events on file changes. Client reconnects on disconnect.",
      "status": "completed",
      "priority": 7
    },
    {
      "id": 14,
      "title": "Live updates via SSE",
      "description": "Create useFileWatch hook that connects to SSE endpoint. On 'tickets' event, invalidate tickets query. On 'progress' event, invalidate progress query. Show connection status indicator.",
      "status": "completed",
      "priority": 8
    },
    {
      "id": 15,
      "title": "Status filtering",
      "description": "Add filter controls to ticket list. Filter by status (all, pending, in_progress, completed, failed). Could be tabs or dropdown. Persist filter in URL params.",
      "status": "completed",
      "priority": 9
    },
    {
      "id": 16,
      "title": "Execute ralph commands from UI",
      "description": "Add 'Run Next Ticket' and 'Run All' buttons. tRPC procedure that spawns `ralph-once` or `ralph` in RALPH_DIR. Return immediately (fire-and-forget). File watcher will pick up changes.",
      "status": "completed",
      "priority": 9
    },
    {
      "id": 17,
      "title": "Desktop notifications",
      "description": "Request notification permission on load. When SSE detects ticket status change to 'completed' or 'failed', show desktop notification with ticket title. Only if tab not focused.",
      "status": "completed",
      "priority": 10
    },
    {
      "id": 18,
      "title": "Main page layout",
      "description": "Design src/app/page.tsx layout. Split view: ticket list on left, detail/progress on right. Or tabs. Header with project path display. Responsive for smaller screens.",
      "status": "completed",
      "priority": 4
    },
    {
      "id": 19,
      "title": "Multi-project support",
      "description": "Add project switcher. Store list of project paths in localStorage. Dropdown to switch RALPH_DIR. Add/remove projects. Each project remembers its own filter state.",
      "status": "completed",
      "priority": 99
    },
    {
      "id": 23,
      "title": "Fix useSyncExternalStore infinite loop in useProjects",
      "description": "Bug: getProjectsSnapshot() calls getProjects() which returns a new array reference each time (from JSON.parse). React sees different reference, re-renders, infinite loop. Fix: cache projects at module level. Add `let projectsCache: Project[] = EMPTY_PROJECTS`. getProjectsSnapshot() returns projectsCache. Create refreshCache() that calls `projectsCache = getProjects()` then notifySubscribers(). All mutation functions (addProject, removeProject, setActiveProject) call refreshCache() instead of notifySubscribers(). Initialize cache on first client-side read. Write a test in src/hooks/use-projects.test.ts that renders the useProjects hook using @testing-library/react renderHook(). The test should verify no errors are thrown and that calling the hook multiple times returns stable references. Run `pnpm test` to verify the fix.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 24,
      "title": "Fix hydration mismatch in useNotifications isSupported",
      "description": "Bug: In src/hooks/use-notifications.ts line 133, `isSupported` is computed as `typeof window !== 'undefined' && 'Notification' in window`. This is false on server, true on client, causing hydration mismatch in ConnectionStatusIndicator when notificationIndicator span renders on client but not server. Fix: Change isSupported to use useState + useEffect pattern. Initialize as `const [isSupported, setIsSupported] = useState(false)`, then in a useEffect set `setIsSupported('Notification' in window)`. This ensures server and initial client render both have isSupported=false, then client updates after mount. Test by loading the page and verifying no hydration mismatch warning in console.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 25,
      "title": "ProcessRunner interface and types",
      "description": "Create src/lib/process-runner.ts with types: ProcessHandle { id: string; pid: number }, ProcessStatus (discriminated union: { state: 'running'; pid: number } | { state: 'exited'; code: number | null } | { state: 'not_found' }), ProcessOutputLine { stream: 'stdout' | 'stderr'; line: string; timestamp: number }. Define ProcessRunner interface: start(opts: { command: string; cwd: string }) => Promise<Result<ProcessHandle, Error>>, getStatus(id: string) => ProcessStatus, kill(id: string) => Promise<Result<void, Error>>, onOutput(id: string, cb: (line: ProcessOutputLine) => void) => () => void, listRunning() => ProcessHandle[]. Write unit tests for type guards (isRunning, isExited, etc).",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 26,
      "title": "ProcessRunner implementation",
      "description": "Create src/server/services/process-runner.ts implementing ProcessRunner interface. Use child_process.spawn with stdio: 'pipe'. Store running processes in Map<string, { child: ChildProcess; output: ProcessOutputLine[] }>. Generate unique id (nanoid or uuid). On spawn: attach stdout/stderr listeners, push lines to output array, call registered callbacks. On exit: update status, store exit code. Implement getStatus by checking if process exists and child.exitCode. Implement kill with child.kill(). Implement onOutput by storing callbacks in a Set per process. Write integration tests that spawn a real process (like 'echo hello') and verify output is captured and status transitions work.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 27,
      "title": "tRPC procedures for ProcessRunner",
      "description": "Create src/server/routers/process.ts. Import ProcessRunner instance. Procedures: start(command: string) - calls runner.start with ctx.ralphDir, returns handle or error; status(id: string) - returns ProcessStatus; kill(id: string) - kills process; list() - returns all running handles. Inject ProcessRunner via module-level instance for now (can refactor to DI later). Write tests with a mock ProcessRunner that returns canned responses. Verify each procedure calls the right runner method with right args.",
      "status": "completed",
      "priority": 4
    },
    {
      "id": 28,
      "title": "SSE endpoint for process output streaming",
      "description": "Create src/app/api/process/[id]/stream/route.ts SSE endpoint. Takes process id from params. Calls runner.onOutput(id, ...) to subscribe. Streams ProcessOutputLine as SSE events (event: 'output', data: JSON). On process exit, send event: 'exit' with code, then close stream. Handle client disconnect by unsubscribing. Write test that starts a process, connects to SSE, verifies output events arrive.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 29,
      "title": "useProcessOutput hook",
      "description": "Create src/hooks/use-process-output.ts. Hook takes processId. Connects to SSE endpoint /api/process/[id]/stream. Accumulates output lines in state. Returns { lines: ProcessOutputLine[], isConnected: boolean, exitCode: number | null }. Cleans up SSE connection on unmount or id change. Write test with mock SSE (or integration test with real endpoint).",
      "status": "completed",
      "priority": 6
    },
    {
      "id": 30,
      "title": "ProcessOutputViewer component",
      "description": "Create src/components/ProcessOutputViewer.tsx. Takes processId prop. Uses useProcessOutput hook. Renders output lines in scroll-area with monospace font. stdout in default color, stderr in red. Auto-scroll to bottom (with toggle). Shows 'Process exited with code X' when done. Shows connecting/disconnected state. Write component test that mocks the hook and verifies rendering.",
      "status": "completed",
      "priority": 7
    },
    {
      "id": 31,
      "title": "Update RalphControls to use ProcessRunner",
      "description": "Refactor src/components/RalphControls.tsx. Replace fire-and-forget mutations with new process.start. On click: call start mutation, store returned processId in state. Show 'Running...' with spinner while process active. Poll or subscribe to status. Show ProcessOutputViewer in a collapsible panel or modal. Add 'Stop' button that calls kill. When process exits, show result (success/failure). Clear state to allow running again. Test by mocking tRPC and verifying correct calls and state transitions.",
      "status": "completed",
      "priority": 8
    },
    {
      "id": 32,
      "title": "Remove old fire-and-forget ralph router",
      "description": "Delete or replace src/server/routers/ralph.ts now that ProcessRunner handles execution. Update router index to use new process router. Verify RalphControls works end-to-end. Clean up any unused imports.",
      "status": "completed",
      "priority": 9
    },
    {
      "id": 33,
      "title": "Support RALPH_BIN env var for ralph commands",
      "description": "The process runner calls `ralph` and `ralph-once` directly, but these may not be in PATH. Fix: Read RALPH_BIN env var (path to ralph bin directory). In process-runner.ts start(), if RALPH_BIN is set and command starts with 'ralph', prepend RALPH_BIN to the command path. E.g., `ralph-once` becomes `${RALPH_BIN}/ralph-once`. Add RALPH_BIN to .env.example with a comment. Test by setting RALPH_BIN and verifying ralph commands run.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 34,
      "title": "Validate required env vars on startup",
      "description": "Create src/lib/env.ts that validates important env vars exist on server startup. Check for RALPH_BIN (required). Use Zod to parse process.env with clear error messages. Export typed env object. Import in src/server/trpc.ts or a server-side layout to ensure it runs early. If missing, throw with helpful message like 'Missing RALPH_BIN - set path to ralph bin directory'. Add test that verifies validation works.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 35,
      "title": "Say hi",
      "description": "No-op ticket. Just say 'Hello!' in progress.txt and mark complete. Don't change any code.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 36,
      "title": "Fix file watcher query invalidation with IoC",
      "description": "Bug: useFileWatch uses raw queryClient.invalidateQueries() with manually constructed keys like [['progress']] which don't match tRPC's internal key format. Progress updates don't trigger re-fetch. Fix: Invert control - useFileWatch should accept callbacks for invalidation instead of doing it directly. Change interface to accept onTicketsChange and onProgressChange callbacks. The component using the hook (ConnectionStatusIndicator or wherever) passes in functions that call utils.tickets.list.invalidate() and utils.progress.read.invalidate() respectively. Remove queryClient usage from the hook. Test by running ralph and verifying progress.txt updates appear without refresh.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 37,
      "title": "Side panel UX for ralph controls and output",
      "description": "Redesign ralph controls UX. Create a persistent side panel (right side) that contains: 1) Run Next Ticket and Run All buttons always visible at top, 2) Stop/Cancel button appears when process is running, 3) ProcessOutputViewer below buttons showing real-time output, 4) Panel should be ~300-400px wide or resizable. Move RalphControls out of header into this side panel. The main content area (tickets list, progress viewer) gets the remaining width. Consider making the panel collapsible. Update page.tsx layout to accommodate side panel.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 38,
      "title": "Consolidate status badge utilities",
      "description": "Extract duplicated getStatusBadgeClass() and formatStatus() functions from src/app/page.tsx and src/components/TicketList.tsx into src/lib/ticket-ui.ts. Update both files to import from the shared module. Run pnpm check to verify.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 39,
      "title": "Clean up comments per style guide",
      "description": "Audit all source files for comments. Remove: comments that restate what code does, imperative comments explaining history ('added for X', 'fixed bug where Y'), TODO comments for completed work. Keep: comments providing context on purpose, explaining non-obvious design decisions. If variable/function name is clear, no comment needed. Run pnpm check after.",
      "status": "completed",
      "priority": 4
    },
    {
      "id": 40,
      "title": "Add process output ring buffer",
      "description": "ProcessRunner buffers ALL output lines forever - memory leak for long processes. Fix: Add MAX_OUTPUT_LINES = 5000 constant. When pushing to output array, if length exceeds max, shift oldest. Run pnpm check after.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 41,
      "title": "Add onExit callback to ProcessRunner",
      "description": "SSE endpoint polls every 100ms for process exit - wasteful. Fix: Add onExit(id, callback) to ProcessRunner interface. Store exit callbacks in Map, fire from child.on('exit'). Update /api/process/[id]/stream to use onExit instead of setInterval. Run pnpm check after.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 42,
      "title": "URL-based project routing",
      "description": "ARCHITECTURAL REFACTOR: Replace localStorage/context project management with URL-based routing.\n\n## Why\nCurrent flow is 5 layers: localStorage → ProjectProvider → useProjectContext → TRPCProvider header → server ctx. Complex, causes hydration issues, not bookmarkable.\n\n## Target Architecture\n- URL structure: /project/[encodedPath]/ where encodedPath is base64url of absolute path\n- Project available everywhere via Next.js params - no context needed\n- React Query keys naturally scoped per-project (different URL = different cache)\n- SSE endpoints get project from URL\n\n## Implementation Steps\n1. Create src/lib/project-path.ts with encodeProjectPath()/decodeProjectPath() helpers (base64url)\n2. Create src/app/project/[path]/page.tsx - move current page.tsx content here, get project from params\n3. Create src/app/project/[path]/layout.tsx - wrap with TRPCProvider, pass project to context\n4. Update src/app/page.tsx to be project picker: list recent projects (from cookie), link to add new\n5. Update src/server/trpc.ts context creation - read project from x-ralph-dir header OR from request URL\n6. Update TRPCProvider - remove header logic, project comes from URL now\n7. Update SSE endpoints (/api/watch, /api/process/[id]/stream) - read project from query param ?dir=\n8. Update useFileWatch - pass project as param instead of reading from context\n9. Delete: ProjectProvider.tsx, useProjectContext references, localStorage project logic in projects.ts\n10. Add cookie helpers: getRecentProjects(), addRecentProject() for the picker\n\n## Files to Change\n- CREATE: src/app/project/[path]/page.tsx, src/app/project/[path]/layout.tsx, src/lib/project-path.ts\n- MODIFY: src/app/page.tsx (becomes picker), src/server/trpc.ts, TRPCProvider.tsx, useFileWatch.ts, SSE routes\n- DELETE: ProjectProvider.tsx, most of projects.ts\n\n## Data Flow After\nUser navigates to /project/L21udC9kYXRhLy4uLg==/ → Next.js extracts [path] param → decoded in layout → passed to tRPC context → available server-side. No localStorage, no context threading, no hydration mismatch.\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 6
    },
    {
      "id": 43,
      "title": "Unify SSE into single event stream",
      "description": "ARCHITECTURAL REFACTOR: Consolidate /api/watch and /api/process/[id]/stream into single /api/events endpoint. Do this AFTER ticket #42 (URL-based routing).\n\n## Why\nCurrently 2 separate SSE endpoints doing similar things - separate connection management, message formatting, cleanup logic. Client manages 2 EventSource connections.\n\n## Target Architecture\nSingle endpoint: /api/events?project=encodedPath&topics=tickets,progress,process:id1,process:id2\n- Subscribe to multiple topics in one connection\n- All events have shape: {topic: string, type: string, data: any}\n- Topics: 'tickets', 'progress', 'process:{id}'\n- Event types per topic: tickets/progress have 'change', process has 'output'/'exit'\n\n## Implementation Steps\n1. Create src/app/api/events/route.ts - unified SSE endpoint\n   - Parse topics from query param\n   - For 'tickets'/'progress' topics: setup chokidar watcher (reuse logic from /api/watch)\n   - For 'process:id' topics: subscribe via runner.onOutput() and runner.onExit()\n   - Emit events as {topic, type, data} JSON\n   - Handle cleanup on disconnect\n2. Create src/hooks/use-event-stream.ts - unified client hook\n   - Takes: project, topics[] (can be dynamic)\n   - Returns: subscribe(topic, handler) function, connectionStatus\n   - Internally manages single EventSource, dispatches by topic\n3. Update components to use useEventStream instead of useFileWatch/useProcessOutput\n   - ConnectionStatus: subscribe to 'tickets', 'progress'\n   - RalphSidePanel: subscribe to 'process:{id}' when process running\n4. Delete old endpoints and hooks:\n   - DELETE: /api/watch/route.ts, /api/process/[id]/stream/route.ts\n   - DELETE: use-file-watch.ts, use-process-output.ts\n\n## Event Examples\n{topic: 'tickets', type: 'change', data: {file: 'tickets.json'}}\n{topic: 'progress', type: 'change', data: {file: 'progress.txt'}}\n{topic: 'process:abc123', type: 'output', data: {stream: 'stdout', line: '...', timestamp: 123}}\n{topic: 'process:abc123', type: 'exit', data: {code: 0}}\n\n## Result\nClient: 2 connections → 1 connection\nServer: 2 SSE endpoints → 1 endpoint\nHooks: useFileWatch + useProcessOutput → useEventStream\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 7
    },
    {
      "id": 44,
      "title": "Quick-add tickets with draft status",
      "description": "Add ability to create tickets from the UI with a quick-add flow.\n\n## Changes Required\n\n### 1. Add 'draft' to ticket status schema\n- Update src/lib/schemas.ts to include 'draft' in status enum\n- Draft tickets are ignored by ralph (already documented in RALPH.md)\n\n### 2. Quick-add bar component\n- Create src/components/QuickAddBar.tsx\n- Always-visible input bar at bottom of ticket list\n- Type title, Enter to create as draft\n- Shift+Enter to create as pending (ready immediately)\n- Auto-focus stays in input for rapid entry\n- Show subtle '+' button to expand full form\n\n### 3. Wire up AddTicketForm\n- The existing AddTicketForm.tsx is orphaned (never imported)\n- Add status field (draft/pending) to form\n- Use in expanded mode from QuickAddBar\n- Add to project page layout\n\n### 4. Draft ticket UI\n- Show draft tickets dimmed/faded in list\n- Add 'Mark Ready' button to promote draft → pending\n- Filter toggle to show/hide drafts\n\n### 5. Update ticket-ui.ts\n- Add badge styling for draft status (gray/muted)\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 45,
      "title": "Configurable command buttons",
      "description": "Replace hardcoded ralph commands with config-driven buttons.\n\n## Config File\nRead `.ralph-watch.json` from project root (ralphDir). Schema:\n```json\n{\n  \"commands\": [\n    { \"label\": \"Run Next\", \"cmd\": \"ralph-once\", \"icon\": \"play\" },\n    { \"label\": \"Run All\", \"cmd\": \"ralph\", \"icon\": \"zap\" },\n    { \"label\": \"Build\", \"cmd\": \"pnpm build\", \"icon\": \"hammer\" }\n  ]\n}\n```\n\n## Implementation Steps\n\n### 1. Config schema and loader\n- Create src/lib/project-config.ts with Zod schema\n- CommandConfig: { label: string, cmd: string, icon?: string, destructive?: boolean }\n- ProjectConfig: { commands: CommandConfig[] }\n- Default config if file missing: ralph-once + ralph commands\n\n### 2. tRPC endpoint\n- Add config.get procedure in src/server/routers/config.ts\n- Reads .ralph-watch.json from ctx.ralphDir\n- Returns parsed config or defaults\n\n### 3. Update RalphSidePanel\n- Fetch config via tRPC\n- Render command buttons dynamically from config.commands\n- Map icon names to lucide-react icons\n- If destructive: true, show confirmation dialog before running\n\n### 4. Icon mapping\n- Create icon map: { play: PlayIcon, zap: ZapIcon, hammer: HammerIcon, ... }\n- Fallback to TerminalIcon for unknown icons\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 46,
      "title": "Mobile-responsive UI",
      "description": "Make the UI fully usable on mobile devices.\n\n## Layout Strategy\nUse bottom tab navigation on small screens (< 768px).\n\n### Tabs\n1. **Tickets** - Full-width ticket list with cards\n2. **Progress** - Progress.txt viewer\n3. **Run** - Command buttons + process output\n\n### Implementation Steps\n\n#### 1. Bottom tab bar component\n- Create src/components/BottomTabBar.tsx\n- Three tabs: Tickets, Progress, Run\n- Fixed to bottom, thumb-friendly height (56-64px)\n- Active tab indicator\n- Only renders on mobile (hidden on md+ breakpoint)\n\n#### 2. Mobile layout wrapper\n- Create src/components/MobileLayout.tsx\n- Manages active tab state\n- Renders appropriate content based on tab\n- Full-height content area above tab bar\n\n#### 3. Update project page\n- Detect screen size (useMediaQuery or Tailwind responsive)\n- Render MobileLayout on small screens\n- Render current desktop layout on large screens\n\n#### 4. Touch-friendly adjustments\n- Larger tap targets for buttons (min 44px)\n- Ticket cards: full-width, larger text\n- Swipe gestures optional (nice-to-have)\n- Floating action button for quick-add (bottom-right, above tab bar)\n\n#### 5. Process output on mobile\n- In 'Run' tab, commands at top, output below\n- Output area scrollable, auto-scroll to bottom\n- Larger font for readability\n\n### Breakpoints\n- Mobile: < 768px (tabs, single column)\n- Desktop: >= 768px (current layout)\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 47,
      "title": "Fix process output loss on tab switch",
      "description": "BUG: When browser tab is backgrounded, SSE disconnects and process output is lost. ProcessRunner has a ring buffer but it's not replayed on reconnect.\n\n## Root Cause\n1. Browser throttles/disconnects EventSource when tab backgrounded\n2. Process output arrives → stored in ProcessRunner ring buffer\n3. Tab returns → EventSource reconnects\n4. SSE only streams NEW output, doesn't replay buffer\n5. Output during disconnect is lost\n\n## Fix: Replay buffered output on SSE connect\n\n### 1. Add getOutput method to ProcessRunner\n- In src/lib/process-runner.ts interface: `getOutput(id: string): ProcessOutputLine[]`\n- In src/server/services/process-runner.ts: return `record.output` array (the ring buffer)\n\n### 2. Replay buffer on SSE subscription\n- In src/app/api/events/route.ts, when subscribing to `process:{id}` topic:\n- Call `runner.getOutput(processId)` to get buffered lines\n- Send all buffered lines as 'output' events BEFORE subscribing to live stream\n- This replays history on every connect/reconnect\n\n### 3. Add sessionStorage persistence (client-side backup)\n- In RalphSidePanel.tsx: persist `lines` to sessionStorage on each update\n- Key: `ralph-output-${processId}`\n- On mount: restore from sessionStorage if processId matches\n- Clear on process exit or new process start\n\n### 4. Add visibility-aware reconnection\n- Create src/hooks/use-visibility.ts - detects document.visibilityState\n- In use-event-stream.ts: when tab becomes visible and disconnected, reconnect immediately (skip 3s delay)\n\n### 5. Write integration test\n- Test that simulates disconnect/reconnect and verifies output is preserved\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 48,
      "title": "move the quick add input above the ticket list in desktop mode",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 49,
      "title": "add darkmode configuration with system-default setting",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 50,
      "title": "bugfix: when quick add field is submitted, the entry text is not passed to the detailed form entry",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 51,
      "title": "configure the colour schemes to follow catppuccin styles for light and dark mode",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 52,
      "title": "Refactor RalphSidePanel to state machine + server reconciliation",
      "description": "ARCHITECTURE: Replace fragile useState/useEffect coordination with state machine pattern.\n\n## Problem\nCurrent RalphSidePanel uses multiple useState hooks (`runningProcess`, `processExitCode`, `lines`) coordinated by useEffects. This creates race conditions:\n- Exit event can arrive but state not cleared due to guard conditions\n- SSE disconnect loses events, client stuck showing 'Stop' button\n- 'Process not found' error events ignored\n- No recovery mechanism on reconnect\n\n## Solution: State Machine + Server Reconciliation\n\n### 1. Define process state machine\nCreate src/lib/process-state.ts:\n```typescript\ntype ProcessState =\n  | { status: 'idle' }\n  | { status: 'starting', command: string }\n  | { status: 'running', id: string, pid: number, lines: ProcessOutputLine[] }\n  | { status: 'exiting', id: string, lines: ProcessOutputLine[] }\n  | { status: 'completed', id: string, exitCode: number | null, lines: ProcessOutputLine[] };\n\ntype ProcessAction =\n  | { type: 'START', command: string }\n  | { type: 'STARTED', id: string, pid: number }\n  | { type: 'OUTPUT', id: string, line: ProcessOutputLine }\n  | { type: 'EXIT', id: string, code: number | null }\n  | { type: 'ERROR', id: string, message: string }\n  | { type: 'RESET' }\n  | { type: 'RECONCILE', serverState: 'running' | 'exited' | 'not_found', exitCode?: number | null };\n\nfunction processReducer(state: ProcessState, action: ProcessAction): ProcessState {\n  // Explicit transitions only - invalid actions are no-ops\n  switch (state.status) {\n    case 'idle':\n      if (action.type === 'START') return { status: 'starting', command: action.command };\n      break;\n    case 'starting':\n      if (action.type === 'STARTED') return { status: 'running', id: action.id, pid: action.pid, lines: [] };\n      if (action.type === 'ERROR') return { status: 'idle' };\n      break;\n    case 'running':\n      if (action.type === 'OUTPUT' && action.id === state.id)\n        return { ...state, lines: [...state.lines, action.line] };\n      if (action.type === 'EXIT' && action.id === state.id)\n        return { status: 'completed', id: state.id, exitCode: action.code, lines: state.lines };\n      if (action.type === 'RECONCILE' && action.serverState !== 'running')\n        return { status: 'completed', id: state.id, exitCode: action.exitCode ?? null, lines: state.lines };\n      break;\n    case 'completed':\n      if (action.type === 'RESET') return { status: 'idle' };\n      if (action.type === 'START') return { status: 'starting', command: action.command };\n      break;\n  }\n  return state; // Invalid transition - no-op\n}\n```\n\n### 2. Add onReconnect callback to useEventStream\nIn src/hooks/use-event-stream.ts:\n- Add `onReconnect?: () => void` to options\n- Call it when EventSource reconnects after disconnect\n- This triggers reconciliation\n\n### 3. Refactor RalphSidePanel to use reducer\nReplace useState hooks with single useReducer. SSE events dispatch actions. UI state derived from reducer state.\n\n### 4. Server reconciliation on reconnect\nWhen SSE reconnects, query `trpc.process.status` and dispatch RECONCILE action if server state differs from client.\n\n### 5. Handle 'error' events from SSE\nIn use-event-stream.ts, when type is 'error' for a process topic, treat as exit with null code.\n\n### 6. Write tests\n- Unit test processReducer transitions\n- Test SSE disconnect/reconnect reconciliation\n- Test invalid transitions are no-ops\n- Test rapid start/stop doesn't corrupt state\n\n## Benefits\n- Impossible states are impossible\n- All transitions explicit and testable\n- Server reconciliation handles edge cases\n- No useEffect coordination mess\n- Single source of truth (the reducer)\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 53,
      "title": "use streamdown library to display description block in main pane, not in ticket view",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 54,
      "title": "add a new \"Incomplete\" tab that displays draft, pending, and In Progress tickets, and make that the default",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 55,
      "title": "use streamdown on the progress log display",
      "status": "completed",
      "priority": 12
    },
    {
      "id": 56,
      "title": "fix selected tab styling",
      "description": "remember that border highlights can be cut off by the parent container if the element is already full width/height. a selection border is useful, but need to not look broken and cutoff",
      "status": "completed",
      "priority": 13
    },
    {
      "id": 57,
      "title": "add a ralph control button to follow an existing ralph instance",
      "status": "completed",
      "priority": 14
    },
    {
      "id": 58,
      "title": "move progress log to dedicated page/tab, with scroll-to-bottom and scroll-to-top buttons floating in the bottom right",
      "status": "completed",
      "priority": 133
    },
    {
      "id": 59,
      "title": "fix: make incomplete tab the default one",
      "status": "completed",
      "priority": 1111
    },
    {
      "id": 60,
      "title": "Embedded Claude Code terminal via xterm.js",
      "description": "Add interactive Claude Code terminal as a panel/tab in ralph-watch.\n\n## Security Model\n\nRalph-watch is a LOCAL DEV TOOL. The security model is:\n- By default, terminal is localhost-only (127.0.0.1 / ::1)\n- Remote access requires explicit env var: RALPH_ENABLE_REMOTE_TERMINAL=yes-i-understand-this-is-dangerous\n- NO AUTH PROVIDED - when remote enabled, anyone on your network can access\n- This is intentional: auth is out of scope for a lightweight dev tool\n- Tailscale users: your Tailscale network provides the auth layer\n\n## Implementation\n\n### 1. Install dependencies\n- `node-pty` - spawn claude with pseudo-terminal (native module, needs node-gyp)\n- `xterm` + `@xterm/addon-fit` + `@xterm/addon-web-links` - terminal emulator\n- `ws` or use existing WebSocket solution\n\n### 2. Backend: PTY WebSocket server\nCreate src/server/services/terminal-server.ts:\n- WebSocket endpoint at /api/terminal\n- On connect: check remoteAddress, reject if not localhost (unless env var set)\n- Spawn `claude` via node-pty with appropriate cols/rows\n- Pipe pty stdout → WebSocket\n- Pipe WebSocket messages → pty stdin\n- Handle resize messages from client\n- Cleanup pty on disconnect\n\n```typescript\nconst ALLOW_REMOTE = process.env.RALPH_ENABLE_REMOTE_TERMINAL === 'yes-i-understand-this-is-dangerous';\n\nwss.on('connection', (ws, req) => {\n  const ip = req.socket.remoteAddress;\n  const isLocal = ip === '127.0.0.1' || ip === '::1' || ip === '::ffff:127.0.0.1';\n  \n  if (!isLocal && !ALLOW_REMOTE) {\n    ws.close(1008, 'Terminal only available on localhost');\n    console.warn(`Rejected terminal connection from ${ip}`);\n    return;\n  }\n  \n  // spawn pty...\n});\n```\n\n### 3. Frontend: xterm.js component\nCreate src/components/Terminal.tsx:\n- Initialize xterm.js Terminal instance\n- Connect to /api/terminal WebSocket\n- Handle resize with FitAddon\n- Send resize events to backend\n- Cleanup on unmount\n\n### 4. UI integration\nOptions (pick one):\n- New tab in RalphSidePanel alongside process output\n- Floating/modal terminal (cmd+` to toggle)\n- Dedicated route /project/[path]/terminal\n\nRecommended: Tab in side panel, consistent with existing UI pattern.\n\n### 5. WebSocket endpoint registration\nIn Next.js, WebSocket needs custom server or separate process. Options:\n- Upgrade handler in middleware (complex)\n- Separate ws server on different port (simpler)\n- Use socket.io adapter (overkill)\n\nRecommended: Separate WebSocket server spawned alongside Next.js, configured via env var TERMINAL_WS_PORT (default 3001).\n\n### 6. README security warning\nAdd prominent section:\n```markdown\n## ⚠️ Remote Terminal Access\n\nBy default, the embedded terminal is localhost-only.\n\nTo enable remote access (e.g., for Tailscale):\n```bash\nRALPH_ENABLE_REMOTE_TERMINAL=yes-i-understand-this-is-dangerous pnpm dev\n```\n\n**WARNING:** This exposes a full terminal with your user permissions to anyone who can reach the WebSocket port. No authentication is provided. Only enable this on trusted networks (like Tailscale) where network-level auth exists.\n```\n\n## Files to Create\n- src/server/services/terminal-server.ts - PTY + WebSocket logic\n- src/components/Terminal.tsx - xterm.js wrapper\n- src/hooks/use-terminal.ts - WebSocket connection hook\n- scripts/terminal-server.ts - standalone WS server entry point (if separate process)\n\n## Files to Modify\n- package.json - add dependencies\n- README.md - security warning\n- src/components/RalphSidePanel.tsx - add terminal tab\n- .env.example - document RALPH_ENABLE_REMOTE_TERMINAL and TERMINAL_WS_PORT\n\n## Out of Scope\n- Authentication/authorization\n- Multiple terminal sessions\n- Terminal persistence across page refresh\n- Sandboxing/containerization\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 10
    },
    {
      "id": 61,
      "title": "Terminal UX: bottom pane + auto-start server",
      "description": "Fix terminal server startup and move terminal to bottom pane.\n\n## Problem\n1. Terminal server doesn't start with `pnpm dev` - requires separate `pnpm terminal` command\n2. Terminal is in side panel tab - would be better as resizable bottom pane\n\n## Fix 1: Auto-start terminal server\n\nUpdate package.json dev script to run both Next.js and terminal server:\n\n```json\n\"dev\": \"tsx scripts/terminal-server.ts & next dev\"\n```\n\nOr install concurrently for cleaner output:\n```bash\npnpm add -D concurrently\n```\n```json\n\"dev\": \"concurrently -n next,term -c blue,green \\\"next dev\\\" \\\"tsx scripts/terminal-server.ts\\\"\"\n```\n\n## Fix 2: Move terminal to bottom pane\n\nCurrent: Terminal is a tab in RalphSidePanel (right side)\nTarget: Terminal is a resizable bottom pane, independent of side panel\n\n### Layout changes\n- Create src/components/BottomTerminalPane.tsx\n  - Resizable height (drag handle at top)\n  - Collapsible (minimize to thin bar)\n  - Persists collapsed/height state in localStorage\n- Update project page layout:\n  - Main content + side panel in top section\n  - Terminal pane at bottom (when visible)\n- Remove terminal tab from RalphSidePanel\n- Add toggle button to show/hide terminal (could be in header or floating)\n\n### Suggested structure\n```\n┌─────────────────────────────────────────┐\n│ Header                                  │\n├─────────────────────────┬───────────────┤\n│                         │               │\n│  Tickets / Detail       │  Ralph Side   │\n│                         │  Panel        │\n│                         │               │\n├─────────────────────────┴───────────────┤\n│ ═══ drag handle ═══                     │\n│ Claude Terminal (bottom pane)           │\n│                                         │\n└─────────────────────────────────────────┘\n```\n\n### Implementation\n- Use CSS resize or a library like react-resizable-panels\n- Min height ~100px, max ~60vh\n- Keyboard shortcut to toggle: Cmd+` or Ctrl+`\n- Remember last height in localStorage\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 62,
      "title": "Add ralph-stop action + terminal reconnect button",
      "description": "Two small UX additions.\n\n## 1. Add ralph-stop to command buttons\n\nCurrently only ralph-once and ralph are available. Add ralph-stop to kill a running ralph process.\n\n- Add to default commands in project-config.ts (or .ralph-watch.json)\n- Icon: Square or StopCircle from lucide\n- Mark as destructive: true for confirmation dialog\n- Only show/enable when a ralph process is running (optional, nice-to-have)\n\n## 2. Terminal reconnect button\n\nWhen terminal disconnects (server restart, network blip), user has to manually click Connect again.\n\n- Add \"Reconnect\" button that appears after disconnect/error\n- Or: auto-reconnect with backoff (1s, 2s, 4s...) up to ~30s\n- Show reconnection attempts in terminal: \"Reconnecting (attempt 2)...\"\n- Stop auto-reconnect if user manually disconnects\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 63,
      "title": "append ticket id to route to preserve selection",
      "description": "move source of truth of selected ticket id to the route",
      "status": "completed",
      "priority": 11
    },
    {
      "id": 64,
      "title": "Fix terminal pane layout - use fixed positioning",
      "description": "Bug: Terminal pane can be pushed off-screen when content above it is tall.\n\n## Problem\nBottomTerminalPane is in document flow, not fixed to viewport. When the main content + side panel are tall, the terminal pane renders below the fold and requires scrolling to see.\n\n## Fix\nChange terminal pane to use fixed positioning at viewport bottom:\n\n```tsx\n// When visible, use fixed positioning\nreturn (\n  <div \n    className=\"fixed bottom-0 left-0 right-0 border-t bg-background flex flex-col z-40\"\n    style={{ height }}\n  >\n    ...\n  </div>\n);\n```\n\nAlso need to add padding-bottom to main content area so it doesn't get hidden behind the terminal pane.\n\n## Alternative\nUse a proper panel layout library like react-resizable-panels that handles this correctly.\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 5
    },
    {
      "id": 65,
      "title": "Make terminal font configurable / use better default",
      "description": "Current terminal font (Menlo, Monaco, Courier New) is hard to read compared to typical terminal fonts.\n\n## Options\n\n1. **Use system monospace** - `font-family: ui-monospace, monospace` lets the OS/browser pick\n2. **Match common terminal fonts** - JetBrains Mono, Fira Code, Source Code Pro\n3. **Make configurable** - Add to .ralph-watch.json or localStorage setting\n4. **Detect from system** - Try to read user's terminal font preference\n\n## Implementation\n\nSimplest fix: Update Terminal.tsx xterm config:\n```typescript\nfontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace',\n```\n\nOr add web fonts (increases bundle size).\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 20
    },
    {
      "id": 66,
      "title": "Move terminal to right side pane",
      "description": "Bottom pane is too wide and not tall enough for Claude Code. Move to a wide right side pane.\n\n## New Layout\n\n```\n┌─────────────────────────────────┬─────────────────────────┐\n│ Header                          │                         │\n├─────────────────┬───────────────┤                         │\n│                 │               │                         │\n│  Tickets/Detail │ Ralph Side    │   Claude Terminal       │\n│                 │ Panel         │   (wide right pane)     │\n│                 │               │                         │\n│                 │               │                         │\n└─────────────────┴───────────────┴─────────────────────────┘\n```\n\nThe entire current app (tickets, detail, ralph controls) is the left/main section. Terminal is a new wide right pane that takes ~40-50% of screen width.\n\n## Implementation\n\n- Wrap current layout in a horizontal split\n- Terminal pane on right, resizable width\n- Collapsible (hide completely when not needed)\n- Persist width in localStorage\n- Keep keyboard toggle (Ctrl+`)\n- Remove BottomTerminalPane, create RightTerminalPane\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 67,
      "title": "Fix terminal toggle shortcut for Linux",
      "description": "Cmd+` doesn't work on Linux with Windows keyboard. Need cross-platform shortcut.\n\n## Problem\n- macOS: Cmd+` works\n- Linux with Windows keyboard: Cmd key doesn't exist, Ctrl+` may conflict with terminal emulators\n\n## Fix\n\n1. Use Ctrl+` on Linux/Windows, Cmd+` on macOS:\n```typescript\nconst isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;\nif ((isMac ? e.metaKey : e.ctrlKey) && e.key === '`') {\n  // toggle\n}\n```\n\n2. Or use a different shortcut that works everywhere (e.g., Ctrl+Shift+T, F12)\n\n3. Or make it configurable in .ralph-watch.json\n\n## Files\n- src/components/BottomTerminalPane.tsx - keyboard handler\n- Consider also adding button in header as fallback\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 68,
      "title": "give ticket status badge semantic colours. ensure badge colour logic is centralized and used both in sidebar and ticket description",
      "description": "the badges should use catppuccin theme colours if not already specified in the tailwind config. the background colour should be the semantic colour, while the foreground colour is still readable\n\nthis is a resubmission of a previous ticket since it wasn't resolved",
      "status": "completed",
      "priority": 111
    },
    {
      "id": 69,
      "title": "make the ralph control pane and the ticket sidebars resizeable",
      "status": "completed",
      "priority": 111
    },
    {
      "id": 70,
      "title": "bug: the ralph controls sidepane doesn't actually resize",
      "description": "this is a hard thing to make an integration test for, so can skip making that",
      "status": "completed",
      "priority": 11111
    },
    {
      "id": 71,
      "title": "Mobile terminal support - add Terminal tab to bottom bar",
      "description": "Terminal is not accessible on mobile. Add as a tab in the bottom navigation bar.\n\n## Current State\n- Desktop: Terminal in right pane, toggle with Ctrl+`\n- Mobile: No access to terminal at all\n\n## Implementation\n\n### 1. Add Terminal tab to BottomTabBar\n- Add 4th tab: Tickets | Progress | Run | Terminal\n- Icon: TerminalIcon from lucide\n\n### 2. Update MobileLayout\n- Add 'terminal' to tab state type\n- Render Terminal component when terminal tab active\n- Terminal should be full-height in mobile view\n\n### 3. Mobile control buttons toolbar\nAdd a row of buttons above the keyboard for common terminal controls:\n```\n[ ^C ] [ Tab ] [ Esc ] [ ↑ ] [ ↓ ]\n```\n- ^C sends \\x03 (SIGINT)\n- Tab sends \\t\n- Esc sends \\x1b\n- Arrows send ANSI escape sequences\n- Style as compact, touch-friendly buttons\n- Only show when terminal is active/connected\n\n### 4. Auto-connect behavior\n- On mobile, maybe auto-connect when switching to terminal tab?\n- Or keep manual connect for battery/data savings\n\n### 5. Touch considerations\n- Terminal text might be small - consider larger font on mobile\n- Keyboard handling - iOS/Android virtual keyboards\n- May need viewport adjustments when keyboard appears\n\n## Files\n- src/components/BottomTabBar.tsx - add Terminal tab\n- src/components/MobileLayout.tsx - add terminal view\n- src/components/Terminal.tsx - add mobile prop, control buttons\n- src/components/TerminalControls.tsx - new component for ^C, Tab, etc.\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 10
    },
    {
      "id": 72,
      "title": "PWA support for mobile home screen install",
      "description": "Add PWA manifest so ralph-watch can be installed as a standalone app on mobile.\n\n## Goal\n- Add to Home Screen on iOS/Android\n- Standalone display (no browser chrome)\n- App icon\n\n## NOT needed\n- Offline support (this is a dev tool, needs server)\n- Push notifications (not relevant)\n- Heavy service worker caching (causes dev headaches)\n\n## Implementation\n\n### 1. Add manifest.json\n```json\n// public/manifest.json\n{\n  \"name\": \"Ralph Watch\",\n  \"short_name\": \"Ralph\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#1e1e2e\",\n  \"theme_color\": \"#1e1e2e\",\n  \"icons\": [\n    { \"src\": \"/icon-192.png\", \"sizes\": \"192x192\", \"type\": \"image/png\" },\n    { \"src\": \"/icon-512.png\", \"sizes\": \"512x512\", \"type\": \"image/png\" }\n  ]\n}\n```\n\n### 2. Create app icons\n- Generate 192x192 and 512x512 PNG icons\n- Simple icon: terminal/ticket emoji or letter R\n- Can use realfavicongenerator.net or similar\n\n### 3. Add meta tags to layout\n```tsx\n<link rel=\"manifest\" href=\"/manifest.json\" />\n<meta name=\"theme-color\" content=\"#1e1e2e\" />\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" />\n<link rel=\"apple-touch-icon\" href=\"/icon-192.png\" />\n```\n\n### 4. Optional: minimal service worker\nIf needed for install prompt, add minimal SW that does nothing:\n```js\n// public/sw.js\nself.addEventListener('fetch', () => {});\n```\n\nRegister in layout, but keep it minimal to avoid caching issues in dev.\n\n## Skip next-pwa\nThe package is overkill for this use case and adds caching complexity. Manual manifest + meta tags is sufficient for home screen install.\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 15
    },
    {
      "id": 73,
      "title": "add scroll to top and bottom buttons to mobile progress tab",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 74,
      "title": "Fix extended quick entry form on mobile - bottom cut off",
      "description": "Bug: Extended quick entry form's bottom is cut off on mobile. Likely overflow or fixed positioning issue. Ensure form is fully scrollable/visible on small screens.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 75,
      "title": "Add Shift+Tab button to terminal control buttons",
      "description": "Terminal control buttons (^C, Tab, Esc, arrows) are missing Shift+Tab. Add a Shift+Tab button that sends the appropriate escape sequence for reverse tab navigation.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 76,
      "title": "Make terminal control buttons configurable via JSON",
      "description": "Terminal control buttons (^C, Tab, Esc, etc.) are hardcoded. Allow customization via .ralph-watch.json:\n\n```json\n{\n  \"terminalButtons\": [\n    { \"label\": \"^C\", \"sequence\": \"\\u0003\" },\n    { \"label\": \"Tab\", \"sequence\": \"\\t\" },\n    { \"label\": \"S-Tab\", \"sequence\": \"\\u001b[Z\" },\n    { \"label\": \"Esc\", \"sequence\": \"\\u001b\" }\n  ]\n}\n```\n\nFallback to current defaults if not specified. Update project-config schema and TerminalControls component.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 77,
      "title": "update project Dir selector to suggest existing folders",
      "status": "draft"
    },
    {
      "id": 78,
      "title": "display tickets from latest to oldest in all tabs",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 79,
      "title": "Add session tracking to terminal server",
      "description": "Backend changes to support multiple terminal sessions.\n\n## Current State\n- One WebSocket connection = one PTY process\n- Connection closes → process killed\n- No session persistence or reattachment\n\n## Changes to terminal-server.ts\n\n### 1. Session storage\n```typescript\ninterface TerminalSession {\n  id: string;\n  pty: pty.IPty;\n  cwd: string;\n  label: string;\n  context?: string; // ticket description or custom context\n  createdAt: number;\n  lastAccessed: number;\n}\n\nconst sessions = new Map<string, TerminalSession>();\n```\n\n### 2. Session ID generation\n- Generate unique ID on new session (nanoid or timestamp+random)\n- Return sessionId in 'ready' message: `{ type: 'ready', pid, sessionId }`\n\n### 3. Query params for session control\n- `?session=<id>` - reattach to existing session\n- `?newSession=true` - force new session\n- `?label=<name>` - session label (e.g., \"Main\", \"Ticket #42\")\n- `?context=<text>` - context to pass to Claude via -p flag\n\n### 4. Reattachment logic\n```typescript\nconst requestedSession = searchParams.get('session');\nif (requestedSession && sessions.has(requestedSession)) {\n  // Reattach to existing session\n  const session = sessions.get(requestedSession)!;\n  session.lastAccessed = Date.now();\n  // Wire up existing PTY to new WebSocket\n} else {\n  // Create new session\n}\n```\n\n### 5. Session lifecycle\n- Don't kill PTY on WebSocket disconnect (unlike current behavior)\n- Add orphan timeout: kill sessions with no connection for 5 minutes\n- Add cleanup interval that runs every minute\n- Max sessions limit (e.g., 10) to prevent resource exhaustion\n\n### 6. List sessions endpoint\nAdd message type to list active sessions:\n- Client sends: `{ type: 'list_sessions' }`\n- Server responds: `{ type: 'sessions', sessions: [{ id, label, pid, createdAt }] }`\n\n### 7. Close session explicitly\n- Client sends: `{ type: 'close_session', sessionId }`\n- Server kills PTY, removes from map\n\n## Context passing to Claude\nWhen context is provided, modify spawn command:\n```typescript\nconst cmd = context \n  ? `${CLAUDE_COMMAND} -p \"${escapeForShell(context)}\"`\n  : CLAUDE_COMMAND;\npty.spawn('/bin/sh', ['-c', cmd], { ... });\n```\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 1
    },
    {
      "id": 80,
      "title": "Update useTerminal hook for session support",
      "description": "Frontend hook changes to support multi-session terminals.\n\n## Changes to use-terminal.ts\n\n### 1. New props interface\n```typescript\ninterface UseTerminalOptions {\n  wsPort: number;\n  projectPath: string;\n  sessionId?: string;        // Attach to specific session\n  sessionLabel?: string;     // Label for new session\n  sessionContext?: string;   // Context (ticket description) for new session\n  onSessionCreated?: (sessionId: string) => void;\n}\n```\n\n### 2. Pass session params in WebSocket URL\n```typescript\nconst params = new URLSearchParams({ cwd: projectPath });\nif (sessionId) params.set('session', sessionId);\nif (sessionLabel) params.set('label', sessionLabel);\nif (sessionContext) params.set('context', sessionContext);\n\nconst ws = new WebSocket(`ws://localhost:${wsPort}?${params}`);\n```\n\n### 3. Handle session ID from ready message\n```typescript\ncase 'ready':\n  setStatus('connected');\n  setPid(msg.pid);\n  setCurrentSessionId(msg.sessionId);\n  options.onSessionCreated?.(msg.sessionId);\n  break;\n```\n\n### 4. Add listSessions method\n```typescript\nconst listSessions = useCallback(() => {\n  if (wsRef.current?.readyState === WebSocket.OPEN) {\n    wsRef.current.send(JSON.stringify({ type: 'list_sessions' }));\n  }\n}, []);\n```\n\n### 5. Handle sessions list response\nAdd state and handler for session list:\n```typescript\nconst [sessions, setSessions] = useState<SessionInfo[]>([]);\n\ncase 'sessions':\n  setSessions(msg.sessions);\n  break;\n```\n\n### 6. Add closeSession method\n```typescript\nconst closeSession = useCallback((sessionId: string) => {\n  if (wsRef.current?.readyState === WebSocket.OPEN) {\n    wsRef.current.send(JSON.stringify({ type: 'close_session', sessionId }));\n  }\n}, []);\n```\n\n### 7. Return new values\n```typescript\nreturn {\n  ...existingReturns,\n  currentSessionId,\n  sessions,\n  listSessions,\n  closeSession,\n};\n```\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 2
    },
    {
      "id": 81,
      "title": "Create SessionTabs component",
      "description": "New UI component for switching between terminal sessions.\n\n## Component: src/components/SessionTabs.tsx\n\n### Props\n```typescript\ninterface SessionTabsProps {\n  sessions: SessionInfo[];\n  activeSessionId: string | null;\n  onSelectSession: (sessionId: string) => void;\n  onCloseSession: (sessionId: string) => void;\n  onNewSession: () => void;\n}\n\ninterface SessionInfo {\n  id: string;\n  label: string;\n  pid: number;\n  createdAt: number;\n}\n```\n\n### Layout\nHorizontal tab bar above terminal:\n```\n[ Main ] [ Ticket #42 ] [ Debug ] [+]\n```\n\n- Each tab shows session label\n- Active tab highlighted\n- X button on hover to close (except if only one session)\n- + button at end to create new session\n- Overflow: horizontal scroll or dropdown for many sessions\n\n### Styling\n- Match existing UI patterns (catppuccin theme)\n- Compact height (~32px) to not waste terminal space\n- Subtle border-bottom on active tab\n- Close button appears on hover (small X icon)\n\n### Behavior\n- Click tab → onSelectSession(id)\n- Click X → onCloseSession(id) with confirmation if process running\n- Click + → onNewSession()\n- Double-click tab label → edit session name (stretch goal)\n\n### Empty state\nIf no sessions, show single \"New Session\" button or auto-create default.\n\n### Implementation notes\n- Use Radix Tabs primitive or custom div buttons\n- Keep state external (lifted to parent)\n- Support keyboard nav (arrow keys between tabs)\n\nRun pnpm check after.",
      "status": "completed",
      "priority": 3
    },
    {
      "id": 82,
      "title": "Integrate session tabs into terminal panes",
      "description": "Wire up SessionTabs to RightTerminalPane and MobileLayout.\n\n## Changes to RightTerminalPane.tsx\n\n### 1. Session state management\n```typescript\nconst [sessions, setSessions] = useState<SessionInfo[]>([]);\nconst [activeSessionId, setActiveSessionId] = useState<string | null>(null);\n```\n\n### 2. Fetch sessions on mount\n- Call listSessions() when terminal connects\n- Update sessions state from hook response\n\n### 3. Render SessionTabs above Terminal\n```tsx\n<div className=\"flex flex-col h-full\">\n  <SessionTabs\n    sessions={sessions}\n    activeSessionId={activeSessionId}\n    onSelectSession={handleSelectSession}\n    onCloseSession={handleCloseSession}\n    onNewSession={handleNewSession}\n  />\n  <div className=\"flex-1\">\n    <Terminal sessionId={activeSessionId} ... />\n  </div>\n</div>\n```\n\n### 4. Session switching\n```typescript\nconst handleSelectSession = (id: string) => {\n  setActiveSessionId(id);\n  // Terminal component will reconnect with new sessionId\n};\n```\n\n### 5. New session creation\n```typescript\nconst handleNewSession = () => {\n  // Clear activeSessionId to create new\n  setActiveSessionId(null);\n  // Or show dialog to set label\n};\n```\n\n### 6. Session close\n```typescript\nconst handleCloseSession = (id: string) => {\n  closeSession(id);\n  if (activeSessionId === id) {\n    // Switch to another session or create new\n    const remaining = sessions.filter(s => s.id !== id);\n    setActiveSessionId(remaining[0]?.id ?? null);\n  }\n};\n```\n\n## Changes to MobileLayout.tsx\n\nSame pattern but adapted for mobile:\n- SessionTabs as horizontal scrollable row at top of terminal tab\n- Smaller touch targets but still usable\n- Maybe collapse to dropdown if many sessions\n\n## Changes to Terminal.tsx\n\n### Accept sessionId prop\n```typescript\ninterface TerminalProps {\n  sessionId?: string;\n  sessionLabel?: string;\n  sessionContext?: string;\n  // ... existing props\n}\n```\n\n### Reconnect when sessionId changes\n```typescript\nuseEffect(() => {\n  // Disconnect and reconnect when sessionId changes\n  disconnect();\n  connect();\n}, [sessionId]);\n```\n\n## Persist active session\n- Store activeSessionId in localStorage\n- Restore on page load (if session still exists)\n\nRun pnpm check after.",
      "status": "pending",
      "priority": 4
    },
    {
      "id": 83,
      "title": "Add 'Riff on ticket' button to DetailPanel",
      "description": "Add button to open a Claude terminal session with ticket context pre-loaded.\n\n## UI Location\nIn the ticket detail panel (right side of ticket list on desktop), add a button near the Edit/Delete buttons:\n```\n[Edit] [Delete] [Riff 💬]\n```\n\nOr as a more prominent action:\n```\n┌─────────────────────────────────┐\n│ Ticket #42: Fix login bug       │\n│ Status: pending  Priority: 1    │\n├─────────────────────────────────┤\n│ [Riff on this with Claude]      │  ← new button\n├─────────────────────────────────┤\n│ Description...                  │\n```\n\n## Button behavior\n\n### 1. On click:\n```typescript\nconst handleRiffOnTicket = () => {\n  // Open terminal pane if closed\n  setTerminalVisible(true);\n  \n  // Create new session with ticket context\n  createNewSession({\n    label: `Ticket #${ticket.id}`,\n    context: formatTicketContext(ticket),\n  });\n};\n```\n\n### 2. Format ticket context\n```typescript\nfunction formatTicketContext(ticket: Ticket): string {\n  return `I want to discuss this ticket with you:\n\nTicket #${ticket.id}: ${ticket.title}\nStatus: ${ticket.status}\nPriority: ${ticket.priority ?? 'none'}\n\nDescription:\n${ticket.description ?? '(no description)'}\n\nHelp me think through this task.`;\n}\n```\n\n### 3. Context passed to Claude\nThe terminal server passes this to Claude via `-p` flag, so Claude starts with this context.\n\n## State coordination\n\nNeed to communicate between DetailPanel and RightTerminalPane:\n\n### Option A: Callback prop\nPass `onRiffOnTicket` callback down from page.tsx that:\n1. Opens terminal\n2. Creates session with context\n\n### Option B: Global state/event\nEmit event that RightTerminalPane listens for:\n```typescript\n// In DetailPanel\nwindow.dispatchEvent(new CustomEvent('riff-on-ticket', { detail: ticket }));\n\n// In RightTerminalPane\nuseEffect(() => {\n  const handler = (e: CustomEvent) => {\n    setVisible(true);\n    createSessionWithContext(e.detail);\n  };\n  window.addEventListener('riff-on-ticket', handler);\n  return () => window.removeEventListener('riff-on-ticket', handler);\n}, []);\n```\n\n### Option C: URL-based\nNavigate to `/project/[path]?riff=42` and let page.tsx handle it.\n\nRecommend Option A for simplicity.\n\n## Mobile support\n- On mobile, button switches to Terminal tab and creates session\n- Same context formatting\n\n## Edge cases\n- If terminal server not running, show error toast\n- If ticket has no description, still works (just less context)\n- If session with same ticket already exists, switch to it instead of creating duplicate\n\nRun pnpm check after.",
      "status": "pending",
      "priority": 5
    }
  ]
}
